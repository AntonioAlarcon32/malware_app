// malware_test.cpp: define el punto de entrada de la aplicación.
//

#include "malware_test.h"
#include "../libs/libcurl/headers/curl.h"
#include <iostream>
#include <thread>
#include <Dbt.h>
#include <Shlwapi.h> 
#include <Windows.h>
#include <chrono>
#include <fstream>
#include <filesystem> // C++17, for filesystem operations

using namespace std;
namespace fs = std::filesystem;

size_t write_callback(void* ptr, size_t size, size_t nmemb, std::string* data) {
    data->append((char*)ptr, size * nmemb);
    return size * nmemb;
}

void copyFileToUSB(const std::string& drive) {
    std::string sourcePath = fs::current_path().string() + "\\hello.txt";
    std::string destinationPath = drive + "\\hello.txt";

    // Check if source file exists
    if (fs::exists(sourcePath)) {
        try {
            fs::copy_file(sourcePath, destinationPath, fs::copy_options::overwrite_existing);
            std::cout << "Copied hello.txt to " << drive << std::endl;
        }
        catch (const fs::filesystem_error& e) {
            std::cerr << "Error copying file: " << e.what() << std::endl;
        }
    }
    else {
        std::cerr << "Source file hello.txt not found." << std::endl;
    }
}

void requestEndpoint(const char* url, int sleepTime) {
    CURL* curl;
    CURLcode res;
    std::string readBuffer;

    while (true) {
        curl = curl_easy_init();
        if (curl) {
            curl_easy_setopt(curl, CURLOPT_URL, url);
            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);

            res = curl_easy_perform(curl);
            if (res != CURLE_OK) {
                std::cerr << "curl_easy_perform() failed: " << curl_easy_strerror(res) << std::endl;
            }
            else {
                std::cout << "Response from " << url << ": " << readBuffer << std::endl;
            }

            curl_easy_cleanup(curl);
            readBuffer.clear();
        }

        std::this_thread::sleep_for(std::chrono::seconds(sleepTime));
    }
}

void endpoint1() {
    requestEndpoint("http://192.168.71.1:3000/endpoint1", 10);
}

void endpoint2() {
    requestEndpoint("http://192.168.71.1:3000/endpoint2", 20);
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    if (uMsg == WM_DEVICECHANGE) {
        if (wParam == DBT_DEVICEARRIVAL) {
            PDEV_BROADCAST_HDR lpdb = (PDEV_BROADCAST_HDR)lParam;
            if (lpdb->dbch_devicetype == DBT_DEVTYP_VOLUME) {
                PDEV_BROADCAST_VOLUME lpdbv = (PDEV_BROADCAST_VOLUME)lpdb;
                char driveLetter = 0;
                for (char i = 0; i < 26; i++) {
                    if (lpdbv->dbcv_unitmask & (1 << i)) {
                        driveLetter = 'A' + i;
                        break;
                    }
                }
                if (driveLetter != 0) {
                    std::string drivePath = std::string(1, driveLetter) + ":\\";
                    if (GetDriveTypeA(drivePath.c_str()) == DRIVE_REMOVABLE) {
                        std::cout << "Removable drive inserted: " << drivePath << std::endl;
                        copyFileToUSB(drivePath);
                    

                    }
                }
            }
        }
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

void usbDetectionThread() {
    const char CLASS_NAME[] = "USB Detection Window Class";

    WNDCLASS wc = { };
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = GetModuleHandle(NULL);
    wc.lpszClassName = CLASS_NAME;

    RegisterClass(&wc);

    HWND hwnd = CreateWindowEx(
        0, CLASS_NAME, "USB Detection Window", WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        NULL, NULL, GetModuleHandle(NULL), NULL
    );

    if (hwnd == NULL) {
        return;
    }

    MSG msg = {};
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}

int main() {
    curl_global_init(CURL_GLOBAL_ALL);

    std::thread usbThread(usbDetectionThread);
    std::thread httpThread1(endpoint1);
    std::thread httpThread2(endpoint2);

    usbThread.join();
    httpThread1.join();
    httpThread2.join();

    curl_global_cleanup();
    return 0;
}

